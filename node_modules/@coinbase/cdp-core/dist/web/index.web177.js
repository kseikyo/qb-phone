function r(t, e = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${t}`);
}
function o(t, e) {
  return t.name === e;
}
function c(t) {
  return parseInt(t.name.slice(4), 10);
}
function h(t) {
  switch (t) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function i(t, e) {
  if (!t.usages.includes(e))
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${e}.`);
}
function u(t, e, n) {
  switch (e) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!o(t.algorithm, "HMAC"))
        throw r("HMAC");
      const a = parseInt(e.slice(2), 10);
      if (c(t.algorithm.hash) !== a)
        throw r(`SHA-${a}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!o(t.algorithm, "RSASSA-PKCS1-v1_5"))
        throw r("RSASSA-PKCS1-v1_5");
      const a = parseInt(e.slice(2), 10);
      if (c(t.algorithm.hash) !== a)
        throw r(`SHA-${a}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!o(t.algorithm, "RSA-PSS"))
        throw r("RSA-PSS");
      const a = parseInt(e.slice(2), 10);
      if (c(t.algorithm.hash) !== a)
        throw r(`SHA-${a}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!o(t.algorithm, "Ed25519"))
        throw r("Ed25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!o(t.algorithm, "ECDSA"))
        throw r("ECDSA");
      const a = h(e);
      if (t.algorithm.namedCurve !== a)
        throw r(a, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  i(t, n);
}
export {
  u as checkSigCryptoKey
};
