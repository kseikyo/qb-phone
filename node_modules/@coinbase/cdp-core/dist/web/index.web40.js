import { serializeAuthorizationList as v } from "./index.web61.js";
import { blobsToCommitments as H } from "./index.web92.js";
import { blobsToProofs as V } from "./index.web93.js";
import { commitmentsToVersionedHashes as k } from "./index.web94.js";
import { toBlobSidecars as B } from "./index.web95.js";
import { concatHex as T } from "./index.web68.js";
import { trim as F } from "./index.web74.js";
import { numberToHex as s, bytesToHex as S } from "./index.web62.js";
import { toRlp as b } from "./index.web75.js";
import { assertTransactionEIP1559 as _, assertTransactionEIP2930 as C, assertTransactionEIP4844 as R, assertTransactionEIP7702 as Y, assertTransactionLegacy as j } from "./index.web85.js";
import { getTransactionType as q } from "./index.web83.js";
import { serializeAccessList as h } from "./index.web96.js";
function re(e, t) {
  const i = q(e);
  return i === "eip1559" ? J(e, t) : i === "eip2930" ? K(e, t) : i === "eip4844" ? D(e, t) : i === "eip7702" ? w(e, t) : M(e);
}
function w(e, t) {
  const { authorizationList: i, chainId: o, gas: r, nonce: n, to: c, value: a, maxFeePerGas: f, maxPriorityFeePerGas: x, accessList: d, data: l } = e;
  Y(e);
  const u = h(d), m = v(i);
  return T([
    "0x04",
    b([
      s(o),
      n ? s(n) : "0x",
      x ? s(x) : "0x",
      f ? s(f) : "0x",
      r ? s(r) : "0x",
      c ?? "0x",
      a ? s(a) : "0x",
      l ?? "0x",
      u,
      m,
      ...g(e, t)
    ])
  ]);
}
function D(e, t) {
  const { chainId: i, gas: o, nonce: r, to: n, value: c, maxFeePerBlobGas: a, maxFeePerGas: f, maxPriorityFeePerGas: x, accessList: d, data: l } = e;
  R(e);
  let u = e.blobVersionedHashes, m = e.sidecars;
  if (e.blobs && (typeof u > "u" || typeof m > "u")) {
    const p = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((P) => S(P)), z = e.kzg, y = H({
      blobs: p,
      kzg: z
    });
    if (typeof u > "u" && (u = k({
      commitments: y
    })), typeof m > "u") {
      const P = V({ blobs: p, commitments: y, kzg: z });
      m = B({ blobs: p, commitments: y, proofs: P });
    }
  }
  const G = h(d), L = [
    s(i),
    r ? s(r) : "0x",
    x ? s(x) : "0x",
    f ? s(f) : "0x",
    o ? s(o) : "0x",
    n ?? "0x",
    c ? s(c) : "0x",
    l ?? "0x",
    G,
    a ? s(a) : "0x",
    u ?? [],
    ...g(e, t)
  ], I = [], A = [], E = [];
  if (m)
    for (let p = 0; p < m.length; p++) {
      const { blob: z, commitment: y, proof: P } = m[p];
      I.push(z), A.push(y), E.push(P);
    }
  return T([
    "0x03",
    m ? (
      // If sidecars are enabled, envelope turns into a "wrapper":
      b([L, I, A, E])
    ) : (
      // If sidecars are disabled, standard envelope is used:
      b(L)
    )
  ]);
}
function J(e, t) {
  const { chainId: i, gas: o, nonce: r, to: n, value: c, maxFeePerGas: a, maxPriorityFeePerGas: f, accessList: x, data: d } = e;
  _(e);
  const l = h(x), u = [
    s(i),
    r ? s(r) : "0x",
    f ? s(f) : "0x",
    a ? s(a) : "0x",
    o ? s(o) : "0x",
    n ?? "0x",
    c ? s(c) : "0x",
    d ?? "0x",
    l,
    ...g(e, t)
  ];
  return T([
    "0x02",
    b(u)
  ]);
}
function K(e, t) {
  const { chainId: i, gas: o, data: r, nonce: n, to: c, value: a, accessList: f, gasPrice: x } = e;
  C(e);
  const d = h(f), l = [
    s(i),
    n ? s(n) : "0x",
    x ? s(x) : "0x",
    o ? s(o) : "0x",
    c ?? "0x",
    a ? s(a) : "0x",
    r ?? "0x",
    d,
    ...g(e, t)
  ];
  return T([
    "0x01",
    b(l)
  ]);
}
function M(e, t) {
  const { chainId: i = 0, gas: o, data: r, nonce: n, to: c, value: a, gasPrice: f } = e;
  j(e);
  let x = [
    n ? s(n) : "0x",
    f ? s(f) : "0x",
    o ? s(o) : "0x",
    c ?? "0x",
    a ? s(a) : "0x",
    r ?? "0x"
  ];
  return i > 0 && (x = [
    ...x,
    s(i),
    "0x",
    "0x"
  ]), b(x);
}
function g(e, t) {
  const i = t ?? e, { v: o, yParity: r } = i;
  if (typeof i.r > "u")
    return [];
  if (typeof i.s > "u")
    return [];
  if (typeof o > "u" && typeof r > "u")
    return [];
  const n = F(i.r), c = F(i.s);
  return [typeof r == "number" ? r ? s(1) : "0x" : o === 0n ? "0x" : o === 1n ? s(1) : o === 27n ? "0x" : s(1), n === "0x00" ? "0x" : n, c === "0x00" ? "0x" : c];
}
export {
  re as serializeTransaction,
  g as toYParitySignatureArray
};
