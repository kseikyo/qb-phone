import { hashTypedData as s, serializeErc6492Signature as c, encodeFunctionData as u, pad as m, getTypesForEIP712Domain as g } from "viem";
import { getCurrentUserSync as A } from "./index.native11.js";
import { signEvmHash as l, signEvmTypedData as d, signEvmTransaction as f, signEvmMessage as h } from "./index.native7.js";
import "@coinbase/cdp-api-client";
import { COINBASE_SMART_WALLET_FACTORY_ADDRESS as y, COINBASE_SMART_WALLET_FACTORY_ABI as p } from "./index.native46.js";
import { signAndWrapTypedDataForSmartAccount as v } from "./index.native47.js";
import { toAccount as T } from "./index.native48.js";
function x(n) {
  const r = A();
  if (!r || !r.evmAccounts?.length && !r.evmSmartAccounts?.length)
    throw new Error(
      "No accounts found - user must be authenticated and have at least one EVM account or smart account"
    );
  const i = r.evmAccounts?.includes(n) ?? !1, a = r.evmSmartAccounts?.includes(n) ?? !1;
  if (!i && !a)
    throw new Error(`Cannot sign for address ${n} - not authorized for this account`);
  return T({
    address: n,
    /**
     * Signs a message using CDP's message signing functionality.
     * Supports string messages, hex strings, and byte arrays.
     *
     * @param root0 - The parameters object
     * @param root0.message - The message to sign, can be a string, hex string, or byte array
     * @returns The signature as a hex string
     */
    async signMessage({ message: e }) {
      let t;
      if (typeof e == "string")
        t = e;
      else if ("raw" in e)
        typeof e.raw == "string" ? t = e.raw : t = new TextDecoder().decode(e.raw);
      else
        throw new Error("Unsupported message format");
      return (await h({
        evmAccount: n,
        message: t
      })).signature;
    },
    /**
     * Signs a transaction using CDP's transaction signing functionality.
     * Converts Viem's transaction format to CDP's AllowedEvmTransactionType.
     *
     * @param transaction - The transaction to sign in Viem's format
     * @returns The signature as a hex string
     */
    async signTransaction(e) {
      const t = {
        to: e.to,
        value: e.value,
        data: e.data,
        nonce: e.nonce,
        gas: e.gas,
        chainId: e.chainId ?? 1
      };
      return e.gasPrice !== void 0 ? (t.maxFeePerGas = e.gasPrice, t.maxPriorityFeePerGas = e.gasPrice) : (t.maxFeePerGas = e.maxFeePerGas, t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), (await f({
        evmAccount: n,
        transaction: t
      })).signedTransaction;
    },
    /**
     * Signs EIP-712 typed data using CDP's typed data signing functionality.
     * Handles domain separation and type encoding according to the EIP-712 specification.
     * For smart accounts, implements replay-safe hash and signature wrapping.
     *
     * @param params - The typed data parameters following the EIP-712 specification
     * @returns The signature as a hex string
     */
    async signTypedData(e) {
      if (a) {
        const t = await v({
          smartAccount: n,
          ownerAddress: r.evmAccounts?.[0],
          hash: s(e),
          chainId: Number(e.domain.chainId)
        });
        return c({
          address: y,
          data: u({
            abi: p,
            functionName: "createAccount",
            args: [[m(r.evmAccounts?.[0])], 0n]
          }),
          signature: t.signature
        });
      } else {
        const t = {
          domain: e.domain,
          types: {
            EIP712Domain: g({
              domain: e.domain
            }),
            ...e.types
          },
          primaryType: e.primaryType,
          message: e.message
        };
        return (await d({
          evmAccount: n,
          typedData: t
        })).signature;
      }
    },
    /**
     * Signs a raw message hash using CDP's message signing functionality.
     *
     * @param message - The message hash to sign
     * @returns The signature as a hex string
     */
    async sign(e) {
      return (await l({
        evmAccount: n,
        hash: e.hash
      })).signature;
    }
  });
}
export {
  x as toViemAccount
};
