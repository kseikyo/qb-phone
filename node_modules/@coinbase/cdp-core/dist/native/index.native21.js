import { logOutEndUser as l, refreshAccessToken as o, registerTemporaryWalletSecret as c } from "@coinbase/cdp-api-client";
import "jose";
import { SignJWT as u } from "./index.native45.js";
import { toAuthState as f } from "./index.native35.js";
import "viem";
import { getPlatformCrypto as n } from "./index.native6.js";
import { sortKeys as S } from "./index.native40.js";
import { getCoreOAuthManager as w } from "./index.native28.js";
const i = 60 * 1e3;
class R {
  projectId;
  authState = null;
  walletSecret = null;
  authStateChangeCallbacks = [];
  initPromise = null;
  refreshTimeout = null;
  /**
   * Initializes the token manager.
   *
   * @param projectId - The project ID.
   */
  constructor(e) {
    this.projectId = e, this.initPromise = this._doInitialize();
  }
  /**
   * Gets the current user, or null if there is no user signed in.
   *
   * @returns The current user.
   */
  getUser() {
    return this.authState?.user ?? null;
  }
  /**
   * Returns whether the user is signed in - i.e., whether there is an unexpired
   * access token and user. Attempts to refresh the token if it's expired.
   *
   * @returns True if the user is signed in, false otherwise.
   */
  async isSignedIn() {
    if (!this.authState)
      return !1;
    if (this.authState.expiresAt > Date.now() + i)
      return !0;
    try {
      return await this.getToken() !== null;
    } catch {
      return !1;
    }
  }
  /**
   * Signs out the user, clearing all authentication state.
   */
  async signOut() {
    try {
      await l(this.projectId);
    } catch {
    } finally {
      await this.clearAuthState();
    }
  }
  /**
   * Adds a callback to be called when the auth state changes.
   *
   * @param callback - The function to call when the auth state changes.
   */
  addAuthStateChangeCallback(e) {
    this.authStateChangeCallbacks.push(e), e(this.authState?.user ?? null);
  }
  /**
   * Gets the access token, refreshing it if it is expired. Returns null if the user is not
   * signed in.
   *
   * @returns The access token.
   */
  async getToken() {
    return this.shouldRefreshToken() && await this.refreshAccessToken(), this.authState?.accessToken ?? null;
  }
  /**
   * Gets the expiration time of the access token, or null if the user is not signed in.
   *
   * @returns The expiration time of the access token.
   */
  async getTokenExpiration() {
    return this.authState?.expiresAt ?? null;
  }
  /**
   * Gets the currently registered wallet secret ID. Rejects if the user is not signed in.
   *
   * @returns The wallet secret ID.
   */
  async getWalletSecretId() {
    if (!await this.isSignedIn())
      throw new Error("Cannot get wallet secret ID if the user is not signed in");
    return this.shouldRefreshWalletSecret() && await this.refreshWalletSecret(), this.walletSecret.walletSecretId;
  }
  /**
   * Gets the X-Wallet-Auth header. Rejects if the user is not signed in.
   *
   * @param options - The options for the request.
   * @param options.requestMethod - The HTTP method of the request.
   * @param options.requestHost - The host of the request.
   * @param options.requestPath - The path of the request.
   * @param options.requestData - The data of the request.
   * @returns The X-Wallet-Auth header.
   */
  async getXWalletAuth(e) {
    if (!await this.isSignedIn())
      throw new Error("Cannot get X-Wallet-Auth header if the user is not signed in");
    this.shouldRefreshWalletSecret() && await this.refreshWalletSecret();
    const t = `${e.requestMethod} ${e.requestHost}${e.requestPath}`, r = Math.floor(Date.now() / 1e3), a = n(), s = {
      uris: [t]
    };
    if (e.requestData && Object.keys(e.requestData).length > 0) {
      const h = S(e.requestData);
      s.reqHash = await a.hash(new TextEncoder().encode(JSON.stringify(h)));
    }
    return await new u(s).setProtectedHeader({ alg: "ES256", typ: "JWT" }).setIssuedAt(r).setNotBefore(r).setJti(a.generateRandomId()).sign(this.walletSecret.keyPair.privateKey);
  }
  /**
   * Gets the authentication state.
   *
   * @returns The authentication state.
   */
  getAuthState() {
    return this.authState;
  }
  /**
   * Sets the authentication state.
   *
   * @param authState - The authentication state.
   */
  async setAuthState(e) {
    this.authState = e, this.authStateChangeCallbacks.forEach((t) => t(this.authState?.user ?? null)), this.scheduleTokenRefresh();
  }
  /**
   * Clears the authentication state.
   */
  async clearAuthState() {
    this.authState = null, this.walletSecret = null, this.cancelTokenRefresh(), this.authStateChangeCallbacks.forEach((e) => e(null));
  }
  /**
   * Ensures the AuthManager is initialized before proceeding.
   * If initialization is already in progress, waits for it to complete.
   */
  async ensureInitialized() {
    if (this.initPromise) {
      await this.initPromise;
      return;
    }
    throw new Error("AuthManager not initialized");
  }
  /**
   * Internal async initialization logic.
   */
  async _doInitialize() {
    try {
      await this.refreshAccessToken(), await w().handleOAuthCode();
    } catch (e) {
      console.warn("Failed to refresh access token during initialization:", e);
    }
  }
  /**
   * Returns whether the token should be refreshed.
   *
   * @returns True if the token should be refreshed, false otherwise.
   */
  shouldRefreshToken() {
    return !(this.authState && this.authState.expiresAt > Date.now() + i);
  }
  /**
   * Refreshes the access token and transitions the auth state accordingly.
   * If a refresh is already in progress, it will wait for that refresh to complete.
   *
   * @returns The new access token.
   */
  async refreshAccessToken() {
    try {
      const e = await o(this.projectId, {
        grantType: "refresh_token"
      }), t = f(
        e.accessToken,
        e.validUntil,
        e.endUser
      );
      await this.setAuthState(t);
    } catch {
      await this.signOut();
    }
  }
  /**
   * Schedules a token refresh to occur exactly when shouldRefreshToken() would return true.
   * Uses the same REFRESH_CREDENTIALS_BUFFER_MS timing as the rest of the auth system.
   */
  scheduleTokenRefresh() {
    if (this.cancelTokenRefresh(), !this.authState)
      return;
    const t = this.authState.expiresAt - i - Date.now();
    t <= 0 || (this.refreshTimeout = setTimeout(async () => {
      await this.refreshAccessToken(), this.scheduleTokenRefresh();
    }, t));
  }
  /**
   * Cancels any scheduled token refresh.
   */
  cancelTokenRefresh() {
    this.refreshTimeout && (clearTimeout(this.refreshTimeout), this.refreshTimeout = null);
  }
  /**
   * Returns whether the wallet secret should be refreshed.
   *
   * @returns True if the wallet secret should be refreshed, false otherwise.
   */
  shouldRefreshWalletSecret() {
    return !(this.walletSecret && this.walletSecret.expiresAt > Date.now() + i);
  }
  /**
   * Refreshes the wallet secret. Assumes the user is signed in.
   *
   * @returns The wallet secret.
   */
  async refreshWalletSecret() {
    const e = n(), t = this.walletSecret?.walletSecretId ?? e.generateRandomId(), r = this.walletSecret?.keyPair ?? await e.createKeyPair(), a = this.authState.expiresAt, s = new Date(a).toISOString();
    this.walletSecret = { walletSecretId: t, keyPair: r, expiresAt: a };
    try {
      await c(this.projectId, this.authState.user.userId, {
        walletSecretId: t,
        publicKey: r.publicKeyBase64,
        validUntil: s
      });
    } catch (h) {
      throw this.walletSecret = null, h;
    }
  }
}
export {
  R as AuthManager
};
