import { ModuleResolutionError as n } from "./index.native24.js";
import { decodeBase64 as c, encodeBase64 as a } from "./index.native27.js";
import "@coinbase/cdp-api-client";
import "viem";
const l = {
  /**
   * Creates a secp256r1 key pair for React Native.
   *
   * @returns A promise that resolves to a key pair.
   */
  async createKeyPair() {
    if (typeof crypto > "u" || !crypto.subtle)
      throw new n("react-native-quick-crypto", "crypto.subtle");
    const e = await crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-256"
        // secp256r1
      },
      !1,
      // Do not allow key export for security
      ["sign", "verify"]
      // Key usages
    ), t = await crypto.subtle.exportKey("spki", e.publicKey), r = new Uint8Array(t), o = a(r);
    return e.privateKey[Symbol.toStringTag] || Object.defineProperty(e.privateKey, Symbol.toStringTag, {
      value: "CryptoKey",
      configurable: !1,
      enumerable: !1,
      writable: !1
    }), {
      privateKey: e.privateKey,
      publicKeyBase64: o
    };
  },
  /**
   * Creates an RSA key pair that allows private key export.
   *
   * @returns A promise that resolves to a key pair.
   */
  async createExportKeyPair() {
    if (typeof crypto > "u" || !crypto.subtle)
      throw new n("react-native-quick-crypto", "crypto.subtle");
    const e = await crypto.subtle.generateKey(
      {
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      },
      !0,
      // Allow key export
      ["encrypt", "decrypt"]
    ), t = await crypto.subtle.exportKey("spki", e.publicKey), r = a(new Uint8Array(t));
    return { privateKey: e.privateKey, publicKeyBase64: r };
  },
  /**
   * Computes a hash of the given data.
   *
   * @param data - The data to hash.
   * @returns A promise that resolves to the hex-encoded hash.
   */
  async hash(e) {
    if (typeof crypto > "u" || !crypto.subtle)
      throw new n("react-native-quick-crypto", "crypto.subtle");
    const t = await crypto.subtle.digest("SHA-256", e), r = new Uint8Array(t);
    return Array.from(r).map((y) => y.toString(16).padStart(2, "0")).join("");
  },
  /**
   * Generates a cryptographically secure random identifier.
   *
   * @returns A random hex-encoded identifier.
   */
  generateRandomId() {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new n("react-native-quick-crypto", "crypto.getRandomValues");
    const e = new Uint8Array(16);
    return crypto.getRandomValues(e), Array.from(e, (t) => t.toString(16).padStart(2, "0")).join("");
  },
  /**
   * Generates a cryptographically secure random salt.
   *
   * @returns A random bigint salt.
   */
  generateRandomSalt() {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new n("react-native-quick-crypto", "crypto.getRandomValues");
    const e = new Uint8Array(32);
    crypto.getRandomValues(e);
    let t = 0n;
    for (let r = 0; r < e.length; r++)
      t = (t << 8n) + BigInt(e[r]);
    return t;
  },
  /**
   * Decrypts data using a private key with RSA-OAEP algorithm.
   *
   * @param privateKey - The private key to use for decryption.
   * @param encryptedData - The base64-encoded encrypted data.
   * @returns A promise that resolves to the decrypted string.
   */
  async decryptWithPrivateKey(e, t) {
    if (typeof crypto > "u" || !crypto.subtle)
      throw new n("react-native-quick-crypto", "crypto.subtle");
    const r = c(t);
    return await crypto.subtle.decrypt("RSA-OAEP", e, r);
  }
};
export {
  l as nativeCrypto
};
