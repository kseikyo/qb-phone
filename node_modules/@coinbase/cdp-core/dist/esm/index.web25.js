import "viem";
import "zustand";
import "@coinbase/cdp-api-client";
import { getCurrentUser as u } from "./index.web6.js";
const r = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
class o extends Error {
  /**
   * The error code from EIP1193ErrorCode enum.
   */
  code;
  /**
   * Creates a new EIP-1193 Provider error.
   *
   * @param code - The error code from EIP1193ErrorCode enum.
   * @param message - The error message.
   */
  constructor(t, n) {
    super(n), this.code = t;
  }
}
class c extends Error {
  /**
   * The error code from RPCErrorCode type.
   */
  code;
  /**
   * Creates a new RPC Invalid Params error.
   *
   * @param code - The error code from RPCErrorCode type.
   * @param message - The error message.
   */
  constructor(t, n) {
    super(n), this.code = t;
  }
}
const h = /* @__PURE__ */ new Set([
  "eth_accounts",
  "eth_requestAccounts",
  "personal_sign",
  "eth_sendTransaction",
  "eth_signTypedData_v4",
  "eth_chainId",
  "eth_sign",
  "wallet_disconnect",
  "wallet_switchEthereumChain",
  "wallet_sendCalls",
  "wallet_getCallsStatus",
  "wallet_getCapabilities"
]);
function v(e, { chains: t }) {
  const { method: n, params: a } = e;
  if (typeof n != "string" || n.length === 0)
    throw new c(
      r.rpc.invalidParams,
      "'method' must be a non-empty string."
    );
  const i = (a ?? [])[0]?.chainId;
  if (typeof i == "string" && !t.some((d) => d.id === Number.parseInt(i, 16)))
    throw new o(
      r.provider.unsupportedChain,
      `Chain ${i} not supported - make sure the provider is configured with the correct chains.`
    );
  if (a !== void 0 && !Array.isArray(a))
    throw new c(
      r.rpc.invalidParams,
      "'params' must be an array if provided."
    );
  if (!h.has(n))
    throw new o(
      r.provider.unsupportedMethod,
      `Method ${e.method} not supported`
    );
}
async function s() {
  const e = await u();
  if (!e)
    throw new o(
      r.provider.unauthorized,
      "User not connected"
    );
  return e;
}
async function f(e) {
  const t = await s();
  if (!t.evmAccounts?.includes(e) && !t.evmSmartAccounts?.includes(e))
    throw new o(
      r.provider.unauthorized,
      "Address not owned by user"
    );
  return t;
}
async function A(e) {
  const t = await s();
  if (!t.evmAccounts?.includes(e))
    throw new o(
      r.provider.unauthorized,
      "EOA not owned by user"
    );
  return t;
}
async function _(e) {
  const t = await s();
  if (!t.evmSmartAccounts?.includes(e))
    throw new o(
      r.provider.unauthorized,
      "Smart account not owned by user"
    );
  return t;
}
async function y() {
  const e = await s();
  if (!e.evmSmartAccounts?.[0])
    throw new o(
      r.provider.unauthorized,
      "No EVM smart accounts available"
    );
  return e;
}
export {
  o as EIP1193ProviderError,
  c as RPCRequestError,
  r as STANDARD_ERROR_CODES,
  v as validateRequest,
  s as validateUserConnected,
  y as validateUserHasEvmSmartAccount,
  f as validateUserOwnsAddress,
  A as validateUserOwnsEOA,
  _ as validateUserOwnsSmartAccount
};
