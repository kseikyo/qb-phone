import { withAlg as n } from "./index.web168.js";
import c from "./index.web169.js";
import { isJWK as p, isSecretJWK as a, isPublicJWK as y, isPrivateJWK as f } from "./index.web170.js";
const s = (r) => r?.[Symbol.toStringTag], o = (r, e, t) => {
  if (e.use !== void 0) {
    let i;
    switch (t) {
      case "sign":
      case "verify":
        i = "sig";
        break;
      case "encrypt":
      case "decrypt":
        i = "enc";
        break;
    }
    if (e.use !== i)
      throw new TypeError(`Invalid key for this operation, its "use" must be "${i}" when present`);
  }
  if (e.alg !== void 0 && e.alg !== r)
    throw new TypeError(`Invalid key for this operation, its "alg" must be "${r}" when present`);
  if (Array.isArray(e.key_ops)) {
    let i;
    switch (!0) {
      case t === "sign":
      case r === "dir":
      case r.includes("CBC-HS"):
        i = t;
        break;
      case r.startsWith("PBES2"):
        i = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(r):
        !r.includes("GCM") && r.endsWith("KW") ? i = "unwrapKey" : i = t;
        break;
      case t === "encrypt":
        i = "wrapKey";
        break;
      case t === "decrypt":
        i = r.startsWith("RSA") ? "unwrapKey" : "deriveBits";
        break;
    }
    if (i && e.key_ops?.includes?.(i) === !1)
      throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${i}" when present`);
  }
  return !0;
}, h = (r, e, t) => {
  if (!(e instanceof Uint8Array)) {
    if (p(e)) {
      if (a(e) && o(r, e, t))
        return;
      throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present');
    }
    if (!c(e))
      throw new TypeError(n(r, e, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
    if (e.type !== "secret")
      throw new TypeError(`${s(e)} instances for symmetric algorithms must be of type "secret"`);
  }
}, m = (r, e, t) => {
  if (p(e))
    switch (t) {
      case "decrypt":
      case "sign":
        if (f(e) && o(r, e, t))
          return;
        throw new TypeError("JSON Web Key for this operation be a private JWK");
      case "encrypt":
      case "verify":
        if (y(e) && o(r, e, t))
          return;
        throw new TypeError("JSON Web Key for this operation be a public JWK");
    }
  if (!c(e))
    throw new TypeError(n(r, e, "CryptoKey", "KeyObject", "JSON Web Key"));
  if (e.type === "secret")
    throw new TypeError(`${s(e)} instances for asymmetric algorithms must not be of type "secret"`);
  if (e.type === "public")
    switch (t) {
      case "sign":
        throw new TypeError(`${s(e)} instances for asymmetric algorithm signing must be of type "private"`);
      case "decrypt":
        throw new TypeError(`${s(e)} instances for asymmetric algorithm decryption must be of type "private"`);
    }
  if (e.type === "private")
    switch (t) {
      case "verify":
        throw new TypeError(`${s(e)} instances for asymmetric algorithm verifying must be of type "public"`);
      case "encrypt":
        throw new TypeError(`${s(e)} instances for asymmetric algorithm encryption must be of type "public"`);
    }
}, d = (r, e, t) => {
  r.startsWith("HS") || r === "dir" || r.startsWith("PBES2") || /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(r) || /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(r) ? h(r, e, t) : m(r, e, t);
};
export {
  d as default
};
