import { isJWK as p } from "./index.web170.js";
import { decode as m } from "./index.web122.js";
import y from "./index.web171.js";
import { isCryptoKey as S, isKeyObject as K } from "./index.web169.js";
let c;
const f = async (e, r, s, i = !1) => {
  c ||= /* @__PURE__ */ new WeakMap();
  let n = c.get(e);
  if (n?.[s])
    return n[s];
  const t = await y({ ...r, alg: s });
  return i && Object.freeze(e), n ? n[s] = t : c.set(e, { [s]: t }), t;
}, E = (e, r) => {
  c ||= /* @__PURE__ */ new WeakMap();
  let s = c.get(e);
  if (s?.[r])
    return s[r];
  const i = e.type === "public", n = !!i;
  let t;
  if (e.asymmetricKeyType === "x25519") {
    switch (r) {
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    t = e.toCryptoKey(e.asymmetricKeyType, n, i ? [] : ["deriveBits"]);
  }
  if (e.asymmetricKeyType === "ed25519") {
    if (r !== "EdDSA" && r !== "Ed25519")
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    t = e.toCryptoKey(e.asymmetricKeyType, n, [
      i ? "verify" : "sign"
    ]);
  }
  if (e.asymmetricKeyType === "rsa") {
    let a;
    switch (r) {
      case "RSA-OAEP":
        a = "SHA-1";
        break;
      case "RS256":
      case "PS256":
      case "RSA-OAEP-256":
        a = "SHA-256";
        break;
      case "RS384":
      case "PS384":
      case "RSA-OAEP-384":
        a = "SHA-384";
        break;
      case "RS512":
      case "PS512":
      case "RSA-OAEP-512":
        a = "SHA-512";
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (r.startsWith("RSA-OAEP"))
      return e.toCryptoKey({
        name: "RSA-OAEP",
        hash: a
      }, n, i ? ["encrypt"] : ["decrypt"]);
    t = e.toCryptoKey({
      name: r.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
      hash: a
    }, n, [i ? "verify" : "sign"]);
  }
  if (e.asymmetricKeyType === "ec") {
    const o = (/* @__PURE__ */ new Map([
      ["prime256v1", "P-256"],
      ["secp384r1", "P-384"],
      ["secp521r1", "P-521"]
    ])).get(e.asymmetricKeyDetails?.namedCurve);
    if (!o)
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    r === "ES256" && o === "P-256" && (t = e.toCryptoKey({
      name: "ECDSA",
      namedCurve: o
    }, n, [i ? "verify" : "sign"])), r === "ES384" && o === "P-384" && (t = e.toCryptoKey({
      name: "ECDSA",
      namedCurve: o
    }, n, [i ? "verify" : "sign"])), r === "ES512" && o === "P-521" && (t = e.toCryptoKey({
      name: "ECDSA",
      namedCurve: o
    }, n, [i ? "verify" : "sign"])), r.startsWith("ECDH-ES") && (t = e.toCryptoKey({
      name: "ECDH",
      namedCurve: o
    }, n, i ? [] : ["deriveBits"]));
  }
  if (!t)
    throw new TypeError("given KeyObject instance cannot be used for this algorithm");
  return s ? s[r] = t : c.set(e, { [r]: t }), t;
}, d = async (e, r) => {
  if (e instanceof Uint8Array || S(e))
    return e;
  if (K(e)) {
    if (e.type === "secret")
      return e.export();
    if ("toCryptoKey" in e && typeof e.toCryptoKey == "function")
      try {
        return E(e, r);
      } catch (i) {
        if (i instanceof TypeError)
          throw i;
      }
    let s = e.export({ format: "jwk" });
    return f(e, s, r);
  }
  if (p(e))
    return e.k ? m(e.k) : f(e, e, r, !0);
  throw new Error("unreachable");
};
export {
  d as default
};
