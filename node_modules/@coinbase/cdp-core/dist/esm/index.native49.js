const H = (m) => (h, n, r) => {
  const s = r.subscribe;
  return r.subscribe = (c, i, a) => {
    let l = c;
    if (i) {
      const g = a?.equalityFn || Object.is;
      let v = c(r.getState());
      l = (f) => {
        const u = c(f);
        if (!g(v, u)) {
          const y = v;
          i(v = u, y);
        }
      }, a?.fireImmediately && i(v, v);
    }
    return s(l);
  }, m(h, n, r);
}, R = H;
function F(m, h) {
  let n;
  try {
    n = m();
  } catch {
    return;
  }
  return {
    getItem: (s) => {
      var e;
      const c = (a) => a === null ? null : JSON.parse(a, void 0), i = (e = n.getItem(s)) != null ? e : null;
      return i instanceof Promise ? i.then(c) : c(i);
    },
    setItem: (s, e) => n.setItem(s, JSON.stringify(e, void 0)),
    removeItem: (s) => n.removeItem(s)
  };
}
const p = (m) => (h) => {
  try {
    const n = m(h);
    return n instanceof Promise ? n : {
      then(r) {
        return p(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return p(r)(n);
      }
    };
  }
}, O = (m, h) => (n, r, s) => {
  let e = {
    storage: F(() => localStorage),
    partialize: (t) => t,
    version: 0,
    merge: (t, S) => ({
      ...S,
      ...t
    }),
    ...h
  }, c = !1;
  const i = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
  let l = e.storage;
  if (!l)
    return m(
      (...t) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`
        ), n(...t);
      },
      r,
      s
    );
  const g = () => {
    const t = e.partialize({ ...r() });
    return l.setItem(e.name, {
      state: t,
      version: e.version
    });
  }, v = s.setState;
  s.setState = (t, S) => {
    v(t, S), g();
  };
  const f = m(
    (...t) => {
      n(...t), g();
    },
    r,
    s
  );
  s.getInitialState = () => f;
  let u;
  const y = () => {
    var t, S;
    if (!l) return;
    c = !1, i.forEach((o) => {
      var d;
      return o((d = r()) != null ? d : f);
    });
    const b = ((S = e.onRehydrateStorage) == null ? void 0 : S.call(e, (t = r()) != null ? t : f)) || void 0;
    return p(l.getItem.bind(l))(e.name).then((o) => {
      if (o)
        if (typeof o.version == "number" && o.version !== e.version) {
          if (e.migrate) {
            const d = e.migrate(
              o.state,
              o.version
            );
            return d instanceof Promise ? d.then((I) => [!0, I]) : [!0, d];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, o.state];
      return [!1, void 0];
    }).then((o) => {
      var d;
      const [I, _] = o;
      if (u = e.merge(
        _,
        (d = r()) != null ? d : f
      ), n(u, !0), I)
        return g();
    }).then(() => {
      b?.(u, void 0), u = r(), c = !0, a.forEach((o) => o(u));
    }).catch((o) => {
      b?.(void 0, o);
    });
  };
  return s.persist = {
    setOptions: (t) => {
      e = {
        ...e,
        ...t
      }, t.storage && (l = t.storage);
    },
    clearStorage: () => {
      l?.removeItem(e.name);
    },
    getOptions: () => e,
    rehydrate: () => y(),
    hasHydrated: () => c,
    onHydrate: (t) => (i.add(t), () => {
      i.delete(t);
    }),
    onFinishHydration: (t) => (a.add(t), () => {
      a.delete(t);
    })
  }, e.skipHydration || y(), u || f;
}, w = O;
export {
  F as createJSONStorage,
  w as persist,
  R as subscribeWithSelector
};
