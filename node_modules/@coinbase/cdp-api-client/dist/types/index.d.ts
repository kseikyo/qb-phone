import { AxiosRequestConfig } from 'axios';

export declare type Abi = AbiItem[];

export declare interface AbiFunction {
    type: AbiFunctionType;
    name: string;
    inputs: AbiParameter[];
    outputs: AbiParameter[];
    constant?: boolean;
    payable?: boolean;
    stateMutability: AbiStateMutability;
    gas?: number;
}

export declare type AbiFunctionType = (typeof AbiFunctionType)[keyof typeof AbiFunctionType];

export declare const AbiFunctionType: {
    readonly function: "function";
};

export declare interface AbiInput {
    type: AbiInputType;
    additionalProperties?: unknown;
}

export declare type AbiInputType = (typeof AbiInputType)[keyof typeof AbiInputType];

export declare const AbiInputType: {
    readonly constructor: "constructor";
    readonly error: "error";
    readonly event: "event";
    readonly fallback: "fallback";
    readonly receive: "receive";
};

export declare type AbiItem = AbiFunction | AbiInput;

export declare interface AbiParameter {
    name?: string;
    type: string;
    internalType?: string;
    components?: AbiParameter[];
}

export declare type AbiStateMutability = (typeof AbiStateMutability)[keyof typeof AbiStateMutability];

export declare const AbiStateMutability: {
    readonly pure: "pure";
    readonly view: "view";
    readonly nonpayable: "nonpayable";
    readonly payable: "payable";
};

export declare interface Account {
    accountId: AccountId;
    type: AccountType;
    owner: Owner;
    name?: string;
    projectIds?: ProjectId[];
    createdAt: string;
    updatedAt: string;
}

export declare type AccountId = string;

export declare interface AccountTokenAddressesResponse {
    accountAddress?: string;
    tokenAddresses?: string[];
    totalCount?: number;
}

export declare type AccountType = (typeof AccountType)[keyof typeof AccountType];

export declare const AccountType: {
    readonly prime: "prime";
    readonly business: "business";
    readonly cdp: "cdp";
};

export declare interface AchDetails {
    routingNumber: string;
    accountNumber: string;
    accountType?: AchDetailsAccountType;
    name?: string;
}

export declare type AchDetailsAccountType = (typeof AchDetailsAccountType)[keyof typeof AchDetailsAccountType];

export declare const AchDetailsAccountType: {
    readonly checking: "checking";
    readonly savings: "savings";
};

export declare interface AddressRisk {
    riskLevel?: AddressRiskRiskLevel;
    lastUpdated?: string;
}

export declare type AddressRiskNetwork = (typeof AddressRiskNetwork)[keyof typeof AddressRiskNetwork];

export declare const AddressRiskNetwork: {
    readonly base: "base";
    readonly ethereum: "ethereum";
};

export declare type AddressRiskRiskLevel = (typeof AddressRiskRiskLevel)[keyof typeof AddressRiskRiskLevel];

export declare const AddressRiskRiskLevel: {
    readonly risk_indicated: "risk_indicated";
    readonly no_risk_indicated: "no_risk_indicated";
};

export declare type AlreadyExistsErrorResponse = Error_2;

export declare class APIError extends Error {
    statusCode: number;
    errorType: APIErrorType;
    errorMessage: string;
    correlationId?: string;
    errorLink?: string;
    constructor(statusCode: number, errorType: APIErrorType, errorMessage: string, correlationId?: string, errorLink?: string, cause?: Error);
    toJSON(): {
        errorLink?: string | undefined;
        correlationId?: string | undefined;
        name: string;
        statusCode: number;
        errorType: APIErrorType;
        errorMessage: string;
    };
}

export declare type APIErrorType = ErrorType | HttpErrorType;

export declare interface Asset {
    symbol: AssetSymbol;
    type: AssetType;
    name: string;
    decimals: number;
}

export declare type AssetSymbol = string;

export declare type AssetType = (typeof AssetType)[keyof typeof AssetType];

export declare const AssetType: {
    readonly fiat: "fiat";
    readonly crypto: "crypto";
};

export declare const authenticateUserWithCustomAuth: (projectId: string, options?: SecondParameter<typeof cdpApiClient>) => Promise<AuthenticateUserWithCustomAuth200>;

export declare type AuthenticateUserWithCustomAuth200 = {
    endUser: EndUser;
    isNewEndUser: boolean;
    message: string;
};

export declare type AuthenticateUserWithCustomAuthResult = NonNullable<Awaited<ReturnType<typeof authenticateUserWithCustomAuth>>>;

export declare type AuthenticationMethod = EmailAuthentication | SmsAuthentication | DeveloperJWTAuthentication | OAuth2Authentication;

export declare type AuthenticationMethods = AuthenticationMethod[];

export declare interface AuthManager {
    isSignedIn: () => Promise<boolean>;
    getToken: () => Promise<string | null>;
    getXWalletAuth: (options: {
        requestMethod: string;
        requestHost: string;
        requestPath: string;
        requestData?: Record<string, unknown>;
    }) => Promise<string>;
}

export declare type BadGatewayErrorResponse = Error_2;

export declare interface Balance {
    asset: Asset;
    availableAmount: string;
    totalAmount: string;
}

export declare interface Balances {
    balances: Balance[];
}

export declare interface Business {
    selfOwned?: boolean;
    businessLegalName?: string;
}

export declare interface BusinessCustomer {
    business: Business;
}

export declare interface CapabilitiesMap {
    guestCheckout?: CapabilityStatus;
}

export declare interface CapabilitiesMapRequest {
    guestCheckout?: CapabilityRequested;
}

export declare interface CapabilityRequested {
    requested: boolean;
}

export declare type CapabilityStatus = (typeof CapabilityStatus)[keyof typeof CapabilityStatus];

export declare const CapabilityStatus: {
    readonly enabled: "enabled";
    readonly restricted: "restricted";
    readonly disabled: "disabled";
    readonly pending: "pending";
};

declare const cdpApiClient: <T>(config: AxiosRequestConfig, idempotencyKey?: string) => Promise<T>;

export declare type CdpOptions = {
    debugging?: boolean;
    basePath?: string;
    refreshTokenStorage?: RefreshTokenStorage;
};

export declare interface CommonSwapResponse {
    blockNumber: string;
    toAmount: string;
    toToken: string;
    fees: CommonSwapResponseFees;
    issues: CommonSwapResponseIssues;
    liquidityAvailable: boolean;
    minToAmount: string;
    fromAmount: string;
    fromToken: string;
}

export declare type CommonSwapResponseFees = {
    gasFee: CommonSwapResponseFeesGasFee;
    protocolFee: CommonSwapResponseFeesProtocolFee;
};

export declare type CommonSwapResponseFeesGasFee = TokenFee | null;

export declare type CommonSwapResponseFeesProtocolFee = TokenFee | null;

export declare type CommonSwapResponseIssues = {
    allowance: CommonSwapResponseIssuesAllowance;
    balance: CommonSwapResponseIssuesBalance;
    simulationIncomplete: boolean;
};

export declare type CommonSwapResponseIssuesAllowance = {
    currentAllowance: string;
    spender: string;
} | null;

export declare type CommonSwapResponseIssuesBalance = {
    token: string;
    currentBalance: string;
    requiredBalance: string;
} | null;

export declare const configureCdpApiClient: (options: CdpOptions) => void;

export declare interface CoolPaymentMethod {
    id: string;
    type: CoolPaymentMethodType;
    asset: string;
    name?: string;
    verified?: boolean;
    allowDeposit?: boolean;
    allowWithdraw?: boolean;
    allowOutboundPayment?: boolean;
    limits?: Limit[];
}

export declare type CoolPaymentMethodType = (typeof CoolPaymentMethodType)[keyof typeof CoolPaymentMethodType];

export declare const CoolPaymentMethodType: {
    readonly ach: "ach";
    readonly fedwire: "fedwire";
};

export declare interface CreateAccountRequest {
    owner: string;
    name?: string;
    projectIds?: ProjectId[];
}

export declare const createCustomAuthConfig: (projectId: string, createCustomAuthConfigRequest: CreateCustomAuthConfigRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<CustomAuthConfig>;

export declare interface CreateCustomAuthConfigRequest {
    enabled: boolean;
    jwksUrl: string;
    issuer: string;
    audience?: string;
}

export declare type CreateCustomAuthConfigResult = NonNullable<Awaited<ReturnType<typeof createCustomAuthConfig>>>;

export declare const createEndUserEvmAccount: (projectId: string, userId: string, createEndUserEvmAccountBody: CreateEndUserEvmAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<EndUser>;

export declare type CreateEndUserEvmAccountBody = {
    walletSecretId: string;
};

export declare type CreateEndUserEvmAccountResult = NonNullable<Awaited<ReturnType<typeof createEndUserEvmAccount>>>;

export declare const createEndUserEvmSmartAccount: (projectId: string, userId: string, createEndUserEvmSmartAccountBody: CreateEndUserEvmSmartAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<EndUser>;

export declare type CreateEndUserEvmSmartAccountBody = {
    owner: string;
    enableSpendPermissions: boolean;
};

export declare type CreateEndUserEvmSmartAccountResult = NonNullable<Awaited<ReturnType<typeof createEndUserEvmSmartAccount>>>;

export declare const createEndUserSolanaAccount: (projectId: string, userId: string, createEndUserSolanaAccountBody: CreateEndUserSolanaAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<EndUser>;

export declare type CreateEndUserSolanaAccountBody = {
    walletSecretId: string;
};

export declare type CreateEndUserSolanaAccountResult = NonNullable<Awaited<ReturnType<typeof createEndUserSolanaAccount>>>;

export declare type CreatePaymentMethodRequest = CreatePaymentMethodRequestAch | CreatePaymentMethodRequestFedwire;

export declare interface CreatePaymentMethodRequestAch {
    type: CreatePaymentMethodRequestAchType;
    asset: string;
    ach: AchDetails;
}

export declare type CreatePaymentMethodRequestAchType = (typeof CreatePaymentMethodRequestAchType)[keyof typeof CreatePaymentMethodRequestAchType];

export declare const CreatePaymentMethodRequestAchType: {
    readonly ach: "ach";
};

export declare interface CreatePaymentMethodRequestFedwire {
    type: CreatePaymentMethodRequestFedwireType;
    asset: string;
    fedwire: FedwireDetails;
}

export declare type CreatePaymentMethodRequestFedwireType = (typeof CreatePaymentMethodRequestFedwireType)[keyof typeof CreatePaymentMethodRequestFedwireType];

export declare const CreatePaymentMethodRequestFedwireType: {
    readonly fedwire: "fedwire";
};

export declare interface CreateSpendPermissionRequest {
    walletSecretId: string;
    network: SpendPermissionNetwork;
    spender: string;
    token: string;
    allowance: string;
    period: string;
    start: string;
    end: string;
    salt?: string;
    extraData?: string;
    useCdpPaymaster: boolean;
    paymasterUrl?: string;
}

export declare const createSpendPermissionWithEndUserAccount: (projectId: string, userId: string, address: string, createSpendPermissionRequest: CreateSpendPermissionRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<EvmUserOperation>;

export declare type CreateSpendPermissionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof createSpendPermissionWithEndUserAccount>>>;

export declare type CreateSwapQuoteResponse = CreateSwapQuoteResponseAllOf & CommonSwapResponse;

export declare type CreateSwapQuoteResponseAllOf = {
    permit2: CreateSwapQuoteResponseAllOfPermit2;
    transaction: CreateSwapQuoteResponseAllOfTransaction;
};

export declare type CreateSwapQuoteResponseAllOfPermit2 = {
    hash: string;
    eip712: EIP712Message;
} | null;

export declare type CreateSwapQuoteResponseAllOfTransaction = {
    to: string;
    data: string;
    gas: string;
    gasPrice: string;
    value: string;
};

export declare type CreateSwapQuoteResponseWrapper = CreateSwapQuoteResponse | SwapUnavailableResponse;

export declare interface CustomAuthConfig {
    enabled: boolean;
    jwksUrl: string;
    issuer: string;
    audience?: string;
    createdAt?: string;
    updatedAt?: string;
}

export declare type Customer = CustomerAllOf & CustomerBase & CustomerAllOfTwo & Required<Pick<CustomerAllOf & CustomerBase & CustomerAllOfTwo, "capabilities" | "requirement" | "type">>;

export declare type CustomerAllOf = {
    customerId: CustomerId;
};

export declare type CustomerAllOfTwo = {
    type?: CustomerType;
    capabilities?: CapabilitiesMap;
    readonly requirement?: CustomerAllOfTwoRequirement;
};

export declare type CustomerAllOfTwoRequirement = Requirement & CustomerAllOfTwoRequirementAllOf;

export declare type CustomerAllOfTwoRequirementAllOf = {
    [key: string]: unknown;
};

export declare type CustomerBase = (IndividualCustomer & {
    projectIds?: ProjectId[];
}) | (BusinessCustomer & {
    projectIds?: ProjectId[];
});

export declare type CustomerCreateRequest = CustomerCreateRequestAllOf & CustomerBase;

export declare type CustomerCreateRequestAllOf = {
    type: CustomerType;
    capabilities?: CapabilitiesMapRequest;
};

export declare type CustomerId = string;

export declare type CustomerType = (typeof CustomerType)[keyof typeof CustomerType];

export declare const CustomerType: {
    readonly individual: "individual";
    readonly business: "business";
};

export declare type CustomerUpdateRequest = CustomerUpdateRequestAllOf & CustomerBase;

export declare type CustomerUpdateRequestAllOf = {
    customerId: CustomerId;
    capabilities?: CapabilitiesMapRequest;
};

export declare interface DateOfBirth {
    day?: string;
    month?: string;
    year?: string;
}

export declare interface DeveloperJWTAuthentication {
    type: DeveloperJWTAuthenticationType;
    kid: string;
    sub: string;
}

export declare type DeveloperJWTAuthenticationType = (typeof DeveloperJWTAuthenticationType)[keyof typeof DeveloperJWTAuthenticationType];

export declare const DeveloperJWTAuthenticationType: {
    readonly jwt: "jwt";
};

declare interface Document_2 {
    frontFileId: FileId;
    backFileId: FileId;
}
export { Document_2 as Document }

export declare interface EIP712Domain {
    name?: string;
    version?: string;
    chainId?: number;
    verifyingContract?: string;
    salt?: string;
}

export declare interface EIP712Message {
    domain: EIP712Domain;
    types: EIP712Types;
    primaryType: string;
    message: EIP712MessageMessage;
}

export declare type EIP712MessageMessage = {
    [key: string]: unknown;
};

export declare interface EIP712Types {
    [key: string]: unknown;
}

export declare interface EmailAddress {
    email: string;
    asset: string;
}

export declare interface EmailAuthentication {
    type: EmailAuthenticationType;
    email: string;
}

export declare type EmailAuthenticationType = (typeof EmailAuthenticationType)[keyof typeof EmailAuthenticationType];

export declare const EmailAuthenticationType: {
    readonly email: "email";
};

export declare interface EndUser {
    userId: string;
    authenticationMethods: AuthenticationMethods;
    evmAccounts: string[];
    evmSmartAccounts: string[];
    solanaAccounts: string[];
    createdAt: string;
}

export declare interface Entity {
    entityId: EntityId;
    name: string;
    productionEntityId?: string;
    legalEntityId?: string | null;
    type?: string;
    capabilities: CapabilitiesMap;
    createdAt: string;
    otherInfo?: EntityOtherInfo;
}

export declare type EntityId = string;

export declare type EntityOtherInfo = {
    [key: string]: unknown;
};

declare interface Error_2 {
    errorType: ErrorType;
    errorMessage: string;
    correlationId?: string;
    errorLink?: string;
}
export { Error_2 as Error }

export declare type ErrorType = (typeof ErrorType)[keyof typeof ErrorType];

export declare const ErrorType: {
    readonly already_exists: "already_exists";
    readonly bad_gateway: "bad_gateway";
    readonly faucet_limit_exceeded: "faucet_limit_exceeded";
    readonly forbidden: "forbidden";
    readonly idempotency_error: "idempotency_error";
    readonly internal_server_error: "internal_server_error";
    readonly invalid_request: "invalid_request";
    readonly invalid_sql_query: "invalid_sql_query";
    readonly invalid_signature: "invalid_signature";
    readonly malformed_transaction: "malformed_transaction";
    readonly not_found: "not_found";
    readonly payment_method_required: "payment_method_required";
    readonly rate_limit_exceeded: "rate_limit_exceeded";
    readonly request_canceled: "request_canceled";
    readonly service_unavailable: "service_unavailable";
    readonly timed_out: "timed_out";
    readonly unauthorized: "unauthorized";
    readonly policy_violation: "policy_violation";
    readonly policy_in_use: "policy_in_use";
    readonly account_limit_exceeded: "account_limit_exceeded";
    readonly network_not_tradable: "network_not_tradable";
    readonly guest_permission_denied: "guest_permission_denied";
    readonly guest_region_forbidden: "guest_region_forbidden";
    readonly guest_transaction_limit: "guest_transaction_limit";
    readonly guest_transaction_count: "guest_transaction_count";
    readonly phone_number_verification_expired: "phone_number_verification_expired";
    readonly document_verification_failed: "document_verification_failed";
    readonly recipient_allowlist_violation: "recipient_allowlist_violation";
    readonly recipient_allowlist_pending: "recipient_allowlist_pending";
    readonly travel_rules_recipient_violation: "travel_rules_recipient_violation";
};

export declare interface EthValueCriterion {
    type: EthValueCriterionType;
    ethValue: string;
    operator: EthValueCriterionOperator;
}

export declare type EthValueCriterionOperator = (typeof EthValueCriterionOperator)[keyof typeof EthValueCriterionOperator];

export declare const EthValueCriterionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare type EthValueCriterionType = (typeof EthValueCriterionType)[keyof typeof EthValueCriterionType];

export declare const EthValueCriterionType: {
    readonly ethValue: "ethValue";
};

export declare interface EvmAccount {
    address: string;
    name?: string;
    policies?: string[];
    createdAt?: string;
    updatedAt?: string;
}

export declare interface EvmAddressCriterion {
    type: EvmAddressCriterionType;
    addresses: string[];
    operator: EvmAddressCriterionOperator;
}

export declare type EvmAddressCriterionOperator = (typeof EvmAddressCriterionOperator)[keyof typeof EvmAddressCriterionOperator];

export declare const EvmAddressCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type EvmAddressCriterionType = (typeof EvmAddressCriterionType)[keyof typeof EvmAddressCriterionType];

export declare const EvmAddressCriterionType: {
    readonly evmAddress: "evmAddress";
};

export declare interface EvmCall {
    to: string;
    value: string;
    data: string;
    overrideGasLimit?: string;
}

export declare interface EvmDataCondition {
    function: string;
    params?: EvmDataConditionParamsItem[];
}

export declare type EvmDataConditionParamsItem = EvmDataParameterCondition | EvmDataParameterConditionList;

export declare interface EvmDataCriterion {
    type: EvmDataCriterionType;
    abi: EvmDataCriterionAbi;
    conditions: EvmDataCondition[];
}

export declare type EvmDataCriterionAbi = KnownAbiType | Abi;

export declare type EvmDataCriterionType = (typeof EvmDataCriterionType)[keyof typeof EvmDataCriterionType];

export declare const EvmDataCriterionType: {
    readonly evmData: "evmData";
};

export declare interface EvmDataParameterCondition {
    name: string;
    operator: EvmDataParameterConditionOperator;
    value: string;
}

export declare interface EvmDataParameterConditionList {
    name: string;
    operator: EvmDataParameterConditionListOperator;
    values: string[];
}

export declare type EvmDataParameterConditionListOperator = (typeof EvmDataParameterConditionListOperator)[keyof typeof EvmDataParameterConditionListOperator];

export declare const EvmDataParameterConditionListOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type EvmDataParameterConditionOperator = (typeof EvmDataParameterConditionOperator)[keyof typeof EvmDataParameterConditionOperator];

export declare const EvmDataParameterConditionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare interface EvmMessageCriterion {
    type: EvmMessageCriterionType;
    match: string;
}

export declare type EvmMessageCriterionType = (typeof EvmMessageCriterionType)[keyof typeof EvmMessageCriterionType];

export declare const EvmMessageCriterionType: {
    readonly evmMessage: "evmMessage";
};

export declare interface EvmNetworkCriterion {
    type: EvmNetworkCriterionType;
    networks: EvmNetworkCriterionNetworksItem[];
    operator: EvmNetworkCriterionOperator;
}

export declare type EvmNetworkCriterionNetworksItem = (typeof EvmNetworkCriterionNetworksItem)[keyof typeof EvmNetworkCriterionNetworksItem];

export declare const EvmNetworkCriterionNetworksItem: {
    readonly "base-sepolia": "base-sepolia";
    readonly base: "base";
    readonly ethereum: "ethereum";
    readonly "ethereum-sepolia": "ethereum-sepolia";
    readonly avalanche: "avalanche";
    readonly polygon: "polygon";
    readonly optimism: "optimism";
    readonly arbitrum: "arbitrum";
    readonly zora: "zora";
    readonly bnb: "bnb";
};

export declare type EvmNetworkCriterionOperator = (typeof EvmNetworkCriterionOperator)[keyof typeof EvmNetworkCriterionOperator];

export declare const EvmNetworkCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type EvmNetworkCriterionType = (typeof EvmNetworkCriterionType)[keyof typeof EvmNetworkCriterionType];

export declare const EvmNetworkCriterionType: {
    readonly evmNetwork: "evmNetwork";
};

export declare interface EvmSmartAccount {
    address: string;
    owners: string[];
    name?: string;
    policies?: string[];
    createdAt?: string;
    updatedAt?: string;
}

export declare interface EvmSpendPermissionsCreateSpendPermissionRequest {
    network: SpendPermissionNetwork;
    spender: string;
    token: string;
    allowance: string;
    period: string;
    start: string;
    end: string;
    salt?: string;
    extraData?: string;
    paymasterUrl?: string;
}

export declare interface EvmSpendPermissionsRevokeSpendPermissionRequest {
    network: SpendPermissionNetwork;
    permissionHash: string;
    paymasterUrl?: string;
}

export declare type EvmSwapsNetwork = (typeof EvmSwapsNetwork)[keyof typeof EvmSwapsNetwork];

export declare const EvmSwapsNetwork: {
    readonly base: "base";
    readonly ethereum: "ethereum";
    readonly arbitrum: "arbitrum";
    readonly optimism: "optimism";
};

export declare interface EvmTypedAddressCondition {
    addresses: string[];
    operator: EvmTypedAddressConditionOperator;
    path: string;
}

export declare type EvmTypedAddressConditionOperator = (typeof EvmTypedAddressConditionOperator)[keyof typeof EvmTypedAddressConditionOperator];

export declare const EvmTypedAddressConditionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare interface EvmTypedNumericalCondition {
    value: string;
    operator: EvmTypedNumericalConditionOperator;
    path: string;
}

export declare type EvmTypedNumericalConditionOperator = (typeof EvmTypedNumericalConditionOperator)[keyof typeof EvmTypedNumericalConditionOperator];

export declare const EvmTypedNumericalConditionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare interface EvmTypedStringCondition {
    match: string;
    path: string;
}

export declare interface EvmUserOperation {
    network: EvmUserOperationNetwork;
    userOpHash: string;
    calls: EvmCall[];
    status: EvmUserOperationStatus;
    transactionHash?: string;
    receipts?: UserOperationReceipt[];
}

export declare type EvmUserOperationNetwork = (typeof EvmUserOperationNetwork)[keyof typeof EvmUserOperationNetwork];

export declare const EvmUserOperationNetwork: {
    readonly "base-sepolia": "base-sepolia";
    readonly base: "base";
    readonly arbitrum: "arbitrum";
    readonly optimism: "optimism";
    readonly zora: "zora";
    readonly polygon: "polygon";
    readonly bnb: "bnb";
    readonly avalanche: "avalanche";
    readonly ethereum: "ethereum";
    readonly "ethereum-sepolia": "ethereum-sepolia";
};

export declare type EvmUserOperationStatus = (typeof EvmUserOperationStatus)[keyof typeof EvmUserOperationStatus];

export declare const EvmUserOperationStatus: {
    readonly pending: "pending";
    readonly signed: "signed";
    readonly broadcast: "broadcast";
    readonly complete: "complete";
    readonly dropped: "dropped";
    readonly failed: "failed";
};

export declare const exportEndUserEvmAccount: (projectId: string, userId: string, exportEndUserEvmAccountBody: ExportEndUserEvmAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<ExportEndUserEvmAccount200>;

export declare type ExportEndUserEvmAccount200 = {
    encryptedPrivateKey: string;
};

export declare type ExportEndUserEvmAccountBody = {
    address: string;
    exportEncryptionKey: string;
    walletSecretId: string;
};

export declare type ExportEndUserEvmAccountResult = NonNullable<Awaited<ReturnType<typeof exportEndUserEvmAccount>>>;

export declare const exportEndUserSolanaAccount: (projectId: string, userId: string, exportEndUserSolanaAccountBody: ExportEndUserSolanaAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<ExportEndUserSolanaAccount200>;

export declare type ExportEndUserSolanaAccount200 = {
    encryptedPrivateKey: string;
};

export declare type ExportEndUserSolanaAccountBody = {
    address: string;
    exportEncryptionKey: string;
    walletSecretId: string;
};

export declare type ExportEndUserSolanaAccountResult = NonNullable<Awaited<ReturnType<typeof exportEndUserSolanaAccount>>>;

export declare interface FedwireDetails {
    accountNumber: string;
    intermediaryBankId?: string;
    beneficiaryBankId: string;
    beneficiaryBankName?: string;
}

export declare type FileId = string;

export declare type ForbiddenErrorResponse = Error_2;

export declare type FromAmount = string;

export declare type FromToken = string;

export declare type GasPrice = string;

export declare const getAuthenticatedEndUser: (projectId: string, userId: string, options?: SecondParameter<typeof cdpApiClient>) => Promise<EndUser>;

export declare type GetAuthenticatedEndUserResult = NonNullable<Awaited<ReturnType<typeof getAuthenticatedEndUser>>>;

export declare type GetSwapPriceResponse = CommonSwapResponse & GetSwapPriceResponseAllOf;

export declare type GetSwapPriceResponseAllOf = {
    gas: string | null;
    gasPrice: string;
};

export declare type GetSwapPriceResponseWrapper = GetSwapPriceResponse | SwapUnavailableResponse;

export declare const getUserOperationWithEndUserAccount: (projectId: string, userId: string, address: string, userOpHash: string, options?: SecondParameter<typeof cdpApiClient>) => Promise<EvmUserOperation>;

export declare type GetUserOperationWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof getUserOperationWithEndUserAccount>>>;

export declare const HttpErrorType: {
    readonly unexpected_error: "unexpected_error";
    readonly unauthorized: "unauthorized";
    readonly not_found: "not_found";
    readonly bad_gateway: "bad_gateway";
    readonly service_unavailable: "service_unavailable";
    readonly unknown: "unknown";
};

export declare type HttpErrorType = (typeof HttpErrorType)[keyof typeof HttpErrorType];

export declare type IdempotencyErrorResponse = Error_2;

export declare type IdempotencyKeyParameter = string;

export declare interface Idl {
    address: string;
    instructions: IdlInstructionsItem[];
    metadata?: IdlMetadata;
    types?: IdlTypesItem[];
}

export declare type IdlInstructionsItem = {
    name: string;
    discriminator: number[];
    args: IdlInstructionsItemArgsItem[];
    accounts?: IdlInstructionsItemAccountsItem[];
};

export declare type IdlInstructionsItemAccountsItem = {
    name: string;
    writable?: boolean;
    signer?: boolean;
};

export declare type IdlInstructionsItemArgsItem = {
    name: string;
    type: string;
};

export declare type IdlMetadata = {
    name?: string;
    version?: string;
    spec?: string;
};

export declare type IdlTypesItem = {
    [key: string]: unknown;
};

export declare interface Individual {
    firstName?: string;
    familyName?: string;
    email?: string;
    phone?: string;
    address?: PhysicalAddress;
    dateOfBirth?: DateOfBirth;
    taxNumber?: string;
    nationalities?: string[];
    verification?: IndividualVerification;
}

export declare interface IndividualCustomer {
    individual: Individual;
}

export declare type IndividualVerification = {
    document?: IndividualVerificationDocument;
    additionalDocument?: IndividualVerificationAdditionalDocument;
};

export declare type IndividualVerificationAdditionalDocument = (Document_2 & IndividualVerificationAdditionalDocumentAllOf) | null;

export declare type IndividualVerificationAdditionalDocumentAllOf = {
    [key: string]: unknown;
};

export declare type IndividualVerificationDocument = Document_2 & IndividualVerificationDocumentAllOf;

export declare type IndividualVerificationDocumentAllOf = {
    [key: string]: unknown;
};

export declare const initiateAuthentication: (projectId: string, initiateAuthenticationRequest: InitiateAuthenticationRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<InitiateAuthenticationResponseWrapper>;

export declare type InitiateAuthenticationRequest = InitiateEmailAuthenticationRequest | InitiateSmsAuthenticationRequest | InitiateOAuthAuthenticationRequest;

export declare type InitiateAuthenticationResponseWrapper = InitiateEmailAuthenticationResponse | InitiateSmsAuthenticationResponse | InitiateOAuthAuthenticationResponse;

export declare type InitiateAuthenticationResult = NonNullable<Awaited<ReturnType<typeof initiateAuthentication>>>;

export declare interface InitiateEmailAuthenticationNextStep {
    type: InitiateEmailAuthenticationNextStepType;
    url: string;
}

export declare type InitiateEmailAuthenticationNextStepType = (typeof InitiateEmailAuthenticationNextStepType)[keyof typeof InitiateEmailAuthenticationNextStepType];

export declare const InitiateEmailAuthenticationNextStepType: {
    readonly "verify-otp": "verify-otp";
};

export declare interface InitiateEmailAuthenticationRequest {
    type: InitiateEmailAuthenticationRequestType;
    email: string;
}

export declare type InitiateEmailAuthenticationRequestType = (typeof InitiateEmailAuthenticationRequestType)[keyof typeof InitiateEmailAuthenticationRequestType];

export declare const InitiateEmailAuthenticationRequestType: {
    readonly email: "email";
};

export declare interface InitiateEmailAuthenticationResponse {
    message: string;
    flowId: string;
    nextStep: InitiateEmailAuthenticationNextStep;
}

export declare interface InitiateOAuthAuthenticationRequest {
    type: OAuth2ProviderType;
    redirectUrl: string;
}

export declare interface InitiateOAuthAuthenticationResponse {
    flowId: string;
    authUrl: string;
}

export declare interface InitiateSmsAuthenticationNextStep {
    type: InitiateSmsAuthenticationNextStepType;
    url: string;
}

export declare type InitiateSmsAuthenticationNextStepType = (typeof InitiateSmsAuthenticationNextStepType)[keyof typeof InitiateSmsAuthenticationNextStepType];

export declare const InitiateSmsAuthenticationNextStepType: {
    readonly "verify-otp": "verify-otp";
};

export declare interface InitiateSmsAuthenticationRequest {
    type: InitiateSmsAuthenticationRequestType;
    phoneNumber: string;
}

export declare type InitiateSmsAuthenticationRequestType = (typeof InitiateSmsAuthenticationRequestType)[keyof typeof InitiateSmsAuthenticationRequestType];

export declare const InitiateSmsAuthenticationRequestType: {
    readonly sms: "sms";
};

export declare interface InitiateSmsAuthenticationResponse {
    message: string;
    flowId: string;
    nextStep: InitiateSmsAuthenticationNextStep;
}

export declare type InternalServerErrorResponse = Error_2;

export declare type InvalidSQLQueryErrorResponse = Error_2;

export declare interface Invitation {
    inviteId: InvitationId;
    entityId: EntityId;
    email: string;
    role: Role;
    status: InvitationStatus;
    invitedAt: string;
    invitedByMemberId: TeamMemberId;
    acceptedAt?: string | null;
    rejectedAt?: string | null;
    expiresAt: string;
}

export declare type InvitationId = string;

export declare type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus];

export declare const InvitationStatus: {
    readonly pending: "pending";
    readonly accepted: "accepted";
    readonly rejected: "rejected";
    readonly canceled: "canceled";
    readonly expired: "expired";
};

export declare function isOpenAPIError(obj: unknown): obj is Error_2;

export declare type KnownAbiType = (typeof KnownAbiType)[keyof typeof KnownAbiType];

export declare const KnownAbiType: {
    readonly erc20: "erc20";
    readonly erc721: "erc721";
    readonly erc1155: "erc1155";
};

export declare type KnownIdlType = (typeof KnownIdlType)[keyof typeof KnownIdlType];

export declare const KnownIdlType: {
    readonly SystemProgram: "SystemProgram";
    readonly TokenProgram: "TokenProgram";
    readonly AssociatedTokenProgram: "AssociatedTokenProgram";
};

export declare interface Limit {
    remaining?: LimitRemaining;
    used?: LimitUsed;
    total?: LimitTotal;
    limitPeriod?: LimitPeriod;
    description?: string;
}

export declare type LimitPeriod = (typeof LimitPeriod)[keyof typeof LimitPeriod];

export declare const LimitPeriod: {
    readonly unknown: "unknown";
    readonly daily: "daily";
    readonly weekly: "weekly";
    readonly monthly: "monthly";
    readonly biweekly: "biweekly";
};

export declare type LimitRemaining = {
    amount: string;
    asset: string;
};

export declare type LimitTotal = {
    amount: string;
    asset: string;
};

export declare type LimitUsed = {
    amount: string;
    asset: string;
};

export declare interface LinkableAccount {
    accountId: AccountId;
    type: AccountType;
}

export declare interface LinkableEntity {
    entityId: EntityId;
    name: string;
    type: LinkableEntityType;
    role: LinkableEntityRole;
}

export declare type LinkableEntityRole = (typeof LinkableEntityRole)[keyof typeof LinkableEntityRole];

export declare const LinkableEntityRole: {
    readonly admin: "admin";
    readonly owner: "owner";
};

export declare type LinkableEntityType = (typeof LinkableEntityType)[keyof typeof LinkableEntityType];

export declare const LinkableEntityType: {
    readonly business: "business";
    readonly prime: "prime";
};

export declare type LinkAccountType = (typeof LinkAccountType)[keyof typeof LinkAccountType];

export declare const LinkAccountType: {
    readonly business: "business";
    readonly prime: "prime";
};

export declare type ListEvmTokenBalancesNetwork = (typeof ListEvmTokenBalancesNetwork)[keyof typeof ListEvmTokenBalancesNetwork];

export declare const ListEvmTokenBalancesNetwork: {
    readonly base: "base";
    readonly "base-sepolia": "base-sepolia";
    readonly ethereum: "ethereum";
};

export declare interface ListResponse {
    nextPageToken?: string;
}

export declare type ListSolanaTokenBalancesNetwork = (typeof ListSolanaTokenBalancesNetwork)[keyof typeof ListSolanaTokenBalancesNetwork];

export declare const ListSolanaTokenBalancesNetwork: {
    readonly solana: "solana";
    readonly "solana-devnet": "solana-devnet";
};

export declare const listSpendPermissionsWithEndUserAccount: (projectId: string, userId: string, address: string, params?: ListSpendPermissionsWithEndUserAccountParams, options?: SecondParameter<typeof cdpApiClient>) => Promise<ListSpendPermissionsWithEndUserAccount200>;

export declare type ListSpendPermissionsWithEndUserAccount200 = ListSpendPermissionsWithEndUserAccount200AllOf & ListResponse;

export declare type ListSpendPermissionsWithEndUserAccount200AllOf = {
    spendPermissions: SpendPermissionResponseObject[];
};

export declare type ListSpendPermissionsWithEndUserAccountParams = {
    pageSize?: PageSizeParameter;
    pageToken?: PageTokenParameter;
};

export declare type ListSpendPermissionsWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof listSpendPermissionsWithEndUserAccount>>>;

export declare const logOutEndUser: (projectId: string, logOutEndUserBody?: LogOutEndUserBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<void>;

export declare type LogOutEndUserBody = {
    refreshToken?: string;
};

export declare type LogOutEndUserResult = NonNullable<Awaited<ReturnType<typeof logOutEndUser>>>;

export declare interface MintAddressCriterion {
    type: MintAddressCriterionType;
    addresses: string[];
    operator: MintAddressCriterionOperator;
}

export declare type MintAddressCriterionOperator = (typeof MintAddressCriterionOperator)[keyof typeof MintAddressCriterionOperator];

export declare const MintAddressCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type MintAddressCriterionType = (typeof MintAddressCriterionType)[keyof typeof MintAddressCriterionType];

export declare const MintAddressCriterionType: {
    readonly mintAddress: "mintAddress";
};

export declare interface NetUSDChangeCriterion {
    type: NetUSDChangeCriterionType;
    changeCents: number;
    operator: NetUSDChangeCriterionOperator;
}

export declare type NetUSDChangeCriterionOperator = (typeof NetUSDChangeCriterionOperator)[keyof typeof NetUSDChangeCriterionOperator];

export declare const NetUSDChangeCriterionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare type NetUSDChangeCriterionType = (typeof NetUSDChangeCriterionType)[keyof typeof NetUSDChangeCriterionType];

export declare const NetUSDChangeCriterionType: {
    readonly netUSDChange: "netUSDChange";
};

export declare type Network = (typeof Network)[keyof typeof Network];

export declare const Network: {
    readonly base: "base";
    readonly ethereum: "ethereum";
    readonly algorand: "algorand";
    readonly aptos: "aptos";
    readonly arbitrum: "arbitrum";
    readonly avacchain: "avacchain";
    readonly noble: "noble";
    readonly optimism: "optimism";
    readonly polygon: "polygon";
    readonly solana: "solana";
    readonly stellar: "stellar";
    readonly sui: "sui";
    readonly unichain: "unichain";
};

export declare interface OAuth2Authentication {
    type: OAuth2ProviderType;
    sub: string;
    email?: string;
    name?: string;
    username?: string;
}

export declare type OAuth2ProviderType = (typeof OAuth2ProviderType)[keyof typeof OAuth2ProviderType];

export declare const OAuth2ProviderType: {
    readonly google: "google";
    readonly apple: "apple";
    readonly x: "x";
};

export declare interface OnchainAddress {
    address: string;
    network: Network;
    destinationTag?: string;
    asset: string;
}

export declare interface OnchainDataColumnSchema {
    name?: string;
    type?: string;
    nullable?: boolean;
    description?: string;
    indexOrder?: number;
    sample?: string;
}

export declare interface OnchainDataQuery {
    sql: string;
    cache?: OnchainDataQueryCache;
}

export declare type OnchainDataQueryCache = {
    maxAgeMs?: number;
};

export declare interface OnchainDataResult {
    result?: OnchainDataResultResultItem[];
    schema?: OnchainDataResultSchema;
    metadata?: OnchainDataResultMetadata;
}

export declare type OnchainDataResultMetadata = {
    cached?: boolean;
    executionTimestamp?: string;
    executionTimeMs?: number;
    rowCount?: number;
};

export declare type OnchainDataResultResultItem = {
    [key: string]: unknown;
};

export declare type OnchainDataResultSchema = {
    columns?: OnchainDataResultSchemaColumnsItem[];
};

export declare type OnchainDataResultSchemaColumnsItem = {
    name?: string;
    type?: OnchainDataResultSchemaColumnsItemType;
};

export declare type OnchainDataResultSchemaColumnsItemType = (typeof OnchainDataResultSchemaColumnsItemType)[keyof typeof OnchainDataResultSchemaColumnsItemType];

export declare const OnchainDataResultSchemaColumnsItemType: {
    readonly String: "String";
    readonly UInt8: "UInt8";
    readonly UInt16: "UInt16";
    readonly UInt32: "UInt32";
    readonly UInt64: "UInt64";
    readonly UInt128: "UInt128";
    readonly UInt256: "UInt256";
    readonly Int8: "Int8";
    readonly Int16: "Int16";
    readonly Int32: "Int32";
    readonly Int64: "Int64";
    readonly Int128: "Int128";
    readonly Int256: "Int256";
    readonly Float32: "Float32";
    readonly Float64: "Float64";
    readonly Bool: "Bool";
    readonly Date: "Date";
    readonly DateTime: "DateTime";
    readonly DateTime64: "DateTime64";
    readonly UUID: "UUID";
};

export declare interface OnchainDataSchemaResponse {
    tables?: OnchainDataTableSchema[];
}

export declare interface OnchainDataTableSchema {
    name?: string;
    description?: string;
    columns?: OnchainDataColumnSchema[];
}

export declare interface OnchainTransaction {
    txHash: string;
    network: Network;
}

export declare interface OnrampOrder {
    orderId: string;
    paymentTotal: string;
    paymentSubtotal: string;
    paymentCurrency: string;
    paymentMethod: OnrampOrderPaymentMethodTypeId;
    purchaseAmount: string;
    purchaseCurrency: string;
    fees: OnrampOrderFee[];
    exchangeRate: string;
    destinationAddress: string;
    destinationNetwork: string;
    status: OnrampOrderStatus;
    txHash?: string;
    createdAt: string;
    updatedAt: string;
    partnerUserRef?: string;
}

export declare interface OnrampOrderFee {
    type: OnrampOrderFeeType;
    amount: string;
    currency: string;
}

export declare type OnrampOrderFeeType = (typeof OnrampOrderFeeType)[keyof typeof OnrampOrderFeeType];

export declare const OnrampOrderFeeType: {
    readonly FEE_TYPE_NETWORK: "FEE_TYPE_NETWORK";
    readonly FEE_TYPE_EXCHANGE: "FEE_TYPE_EXCHANGE";
};

export declare type OnrampOrderPaymentMethodTypeId = (typeof OnrampOrderPaymentMethodTypeId)[keyof typeof OnrampOrderPaymentMethodTypeId];

export declare const OnrampOrderPaymentMethodTypeId: {
    readonly GUEST_CHECKOUT_APPLE_PAY: "GUEST_CHECKOUT_APPLE_PAY";
};

export declare type OnrampOrderStatus = (typeof OnrampOrderStatus)[keyof typeof OnrampOrderStatus];

export declare const OnrampOrderStatus: {
    readonly ONRAMP_ORDER_STATUS_PENDING_AUTH: "ONRAMP_ORDER_STATUS_PENDING_AUTH";
    readonly ONRAMP_ORDER_STATUS_PENDING_PAYMENT: "ONRAMP_ORDER_STATUS_PENDING_PAYMENT";
    readonly ONRAMP_ORDER_STATUS_PROCESSING: "ONRAMP_ORDER_STATUS_PROCESSING";
    readonly ONRAMP_ORDER_STATUS_COMPLETED: "ONRAMP_ORDER_STATUS_COMPLETED";
    readonly ONRAMP_ORDER_STATUS_FAILED: "ONRAMP_ORDER_STATUS_FAILED";
};

export declare interface OnrampPaymentLink {
    url: string;
    paymentLinkType: OnrampPaymentLinkType;
}

export declare type OnrampPaymentLinkType = (typeof OnrampPaymentLinkType)[keyof typeof OnrampPaymentLinkType];

export declare const OnrampPaymentLinkType: {
    readonly PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON: "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON";
};

export declare interface OnrampQuote {
    paymentTotal: string;
    paymentSubtotal: string;
    paymentCurrency: string;
    purchaseAmount: string;
    purchaseCurrency: string;
    destinationNetwork: string;
    fees: OnrampOrderFee[];
    exchangeRate: string;
}

export declare type OnrampQuotePaymentMethodTypeId = (typeof OnrampQuotePaymentMethodTypeId)[keyof typeof OnrampQuotePaymentMethodTypeId];

export declare const OnrampQuotePaymentMethodTypeId: {
    readonly CARD: "CARD";
    readonly ACH: "ACH";
    readonly APPLE_PAY: "APPLE_PAY";
    readonly PAYPAL: "PAYPAL";
    readonly FIAT_WALLET: "FIAT_WALLET";
    readonly CRYPTO_WALLET: "CRYPTO_WALLET";
};

export declare interface OnrampSession {
    onrampUrl: string;
}

export declare type Owner = string;

export declare type PageSizeParameter = number;

export declare type PageTokenParameter = string;

export declare interface PaymentMethod {
    paymentMethodId: string;
    asset: string;
}

export declare type PaymentMethodRequiredErrorResponse = Error_2;

export declare interface Permission {
    permissionId: PermissionId;
    name: string;
    entityId: EntityId;
    subjectType: PermissionSubjectType;
    verb: PermissionVerb;
    object: string;
    description?: string;
    createdAt: string;
}

export declare interface PermissionCatalog {
    verbs: PermissionCatalogVerbsItem[];
    objects: PermissionCatalogObjectsItem[];
}

export declare type PermissionCatalogObjectsItem = {
    id?: string;
    type?: PermissionCatalogObjectsItemType;
    name?: string;
    parentId?: string | null;
};

export declare type PermissionCatalogObjectsItemType = (typeof PermissionCatalogObjectsItemType)[keyof typeof PermissionCatalogObjectsItemType];

export declare const PermissionCatalogObjectsItemType: {
    readonly entity: "entity";
    readonly project: "project";
};

export declare type PermissionCatalogVerbsItem = {
    name?: string;
    displayName?: string;
    description?: string;
};

export declare type PermissionId = string;

export declare type PermissionSubjectType = (typeof PermissionSubjectType)[keyof typeof PermissionSubjectType];

export declare const PermissionSubjectType: {
    readonly team_member: "team_member";
    readonly api_key: "api_key";
};

export declare type PermissionVerb = (typeof PermissionVerb)[keyof typeof PermissionVerb];

export declare const PermissionVerb: {
    readonly create_api_key: "create_api_key";
    readonly read_api_key: "read_api_key";
    readonly update_api_key: "update_api_key";
    readonly delete_api_key: "delete_api_key";
    readonly create_project: "create_project";
    readonly read_project: "read_project";
    readonly update_project: "update_project";
    readonly delete_project: "delete_project";
    readonly read_entity: "read_entity";
    readonly update_entity: "update_entity";
    readonly invite_team_member: "invite_team_member";
    readonly read_team_member: "read_team_member";
    readonly update_team_member: "update_team_member";
    readonly remove_team_member: "remove_team_member";
    readonly create_role: "create_role";
    readonly read_role: "read_role";
    readonly update_role: "update_role";
    readonly delete_role: "delete_role";
    readonly create_permission: "create_permission";
    readonly read_permission: "read_permission";
    readonly update_permission: "update_permission";
    readonly delete_permission: "delete_permission";
    readonly manage_billing: "manage_billing";
    readonly view_audit_logs: "view_audit_logs";
    readonly manage_all: "manage_all";
};

export declare interface PhysicalAddress {
    line1?: string;
    line2?: string;
    city?: string;
    state?: string;
    postCode?: string;
    countryCode?: string;
}

export declare interface Policy {
    id: string;
    description?: string;
    scope: PolicyScope;
    rules: Rule[];
    createdAt: string;
    updatedAt: string;
}

export declare type PolicyScope = (typeof PolicyScope)[keyof typeof PolicyScope];

export declare const PolicyScope: {
    readonly project: "project";
    readonly account: "account";
};

export declare type PrepareUserOperationCriteria = PrepareUserOperationCriteriaItem[];

export declare type PrepareUserOperationCriteriaItem = EthValueCriterion | EvmAddressCriterion | EvmNetworkCriterion | EvmDataCriterion | NetUSDChangeCriterion;

export declare interface PrepareUserOperationRule {
    action: PrepareUserOperationRuleAction;
    operation: PrepareUserOperationRuleOperation;
    criteria: PrepareUserOperationCriteria;
}

export declare type PrepareUserOperationRuleAction = (typeof PrepareUserOperationRuleAction)[keyof typeof PrepareUserOperationRuleAction];

export declare const PrepareUserOperationRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type PrepareUserOperationRuleOperation = (typeof PrepareUserOperationRuleOperation)[keyof typeof PrepareUserOperationRuleOperation];

export declare const PrepareUserOperationRuleOperation: {
    readonly prepareUserOperation: "prepareUserOperation";
};

export declare interface ProgramIdCriterion {
    type: ProgramIdCriterionType;
    programIds: string[];
    operator: ProgramIdCriterionOperator;
}

export declare type ProgramIdCriterionOperator = (typeof ProgramIdCriterionOperator)[keyof typeof ProgramIdCriterionOperator];

export declare const ProgramIdCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type ProgramIdCriterionType = (typeof ProgramIdCriterionType)[keyof typeof ProgramIdCriterionType];

export declare const ProgramIdCriterionType: {
    readonly programId: "programId";
};

export declare interface Project {
    projectId: ProjectId;
    name: string;
    entityId: EntityId;
    sandbox?: boolean;
    createdAt: string;
    updatedAt?: string | null;
    deletedAt?: string | null;
}

export declare type ProjectId = string;

export declare type RateLimitExceededResponse = Error_2;

export declare const refreshAccessToken: (projectId: string, refreshAccessTokenBody: RefreshAccessTokenBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<RefreshAccessToken200>;

export declare type RefreshAccessToken200 = {
    endUser: EndUser;
    accessToken: string;
    validUntil: string;
    refreshToken?: string;
};

export declare type RefreshAccessTokenBody = {
    grantType: RefreshAccessTokenBodyGrantType;
    refreshToken?: string;
};

export declare type RefreshAccessTokenBodyGrantType = (typeof RefreshAccessTokenBodyGrantType)[keyof typeof RefreshAccessTokenBodyGrantType];

export declare const RefreshAccessTokenBodyGrantType: {
    readonly refresh_token: "refresh_token";
};

export declare type RefreshAccessTokenResult = NonNullable<Awaited<ReturnType<typeof refreshAccessToken>>>;

export declare interface RefreshTokenStorage {
    getRefreshToken(): Promise<string | null>;
    setRefreshToken(token: string): Promise<void>;
    removeRefreshToken(): Promise<void>;
}

export declare const registerTemporaryWalletSecret: (projectId: string, userId: string, registerTemporaryWalletSecretBody: RegisterTemporaryWalletSecretBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<RegisterTemporaryWalletSecret200>;

export declare type RegisterTemporaryWalletSecret200 = {
    walletSecretId: string;
    validUntil: string;
};

export declare type RegisterTemporaryWalletSecretBody = {
    publicKey: string;
    validUntil: string;
    walletSecretId?: string;
};

export declare type RegisterTemporaryWalletSecretResult = NonNullable<Awaited<ReturnType<typeof registerTemporaryWalletSecret>>>;

export declare interface Requirement {
    due?: RequirementDue[];
    pending?: RequirementDue[];
    errors?: RequirementError[];
}

export declare interface RequirementDue {
    field: RequirementField;
    deadline?: string;
}

export declare interface RequirementError {
    code: RequirementErrorCode;
    reason: string;
    requirement: RequirementField;
}

export declare type RequirementErrorCode = (typeof RequirementErrorCode)[keyof typeof RequirementErrorCode];

export declare const RequirementErrorCode: {
    readonly information_missing: "information_missing";
    readonly invalid_address: "invalid_address";
    readonly verification_document_dob_mismatch: "verification_document_dob_mismatch";
    readonly verification_document_expired: "verification_document_expired";
};

export declare type RequirementField = (typeof RequirementField)[keyof typeof RequirementField];

export declare const RequirementField: {
    readonly individualfirstName: "individual.firstName";
    readonly individuallastName: "individual.lastName";
    readonly individualdateOfBirth: "individual.dateOfBirth";
    readonly individualaddress: "individual.address";
    readonly individualnationalityCode: "individual.nationalityCode";
    readonly individualtaxNumber: "individual.taxNumber";
    readonly individualverificationdocument: "individual.verification.document";
};

export declare interface RevokeSpendPermissionRequest {
    walletSecretId: string;
    network: SpendPermissionNetwork;
    permissionHash: string;
    useCdpPaymaster: boolean;
    paymasterUrl?: string;
}

export declare const revokeSpendPermissionWithEndUserAccount: (projectId: string, userId: string, address: string, revokeSpendPermissionRequest: RevokeSpendPermissionRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<EvmUserOperation>;

export declare type RevokeSpendPermissionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof revokeSpendPermissionWithEndUserAccount>>>;

export declare interface Role {
    roleId: RoleId;
    name: string;
    description?: string | null;
    permissions: Permission[];
    createdAt?: string;
    updatedAt?: string;
}

export declare type RoleId = "role_entity_admin" | "role_entity_viewer" | string;

export declare type Rule = SignEvmTransactionRule | SendEvmTransactionRule | SignEvmMessageRule | SignEvmTypedDataRule | SignSolTransactionRule | SendSolTransactionRule | SignSolMessageRule | SignEvmHashRule | PrepareUserOperationRule | SendUserOperationRule;

export declare type SecondFactorProofTokenParameter = string;

declare type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export declare type SendEvmTransactionCriteria = SendEvmTransactionCriteriaItem[];

export declare type SendEvmTransactionCriteriaItem = EthValueCriterion | EvmAddressCriterion | EvmNetworkCriterion | EvmDataCriterion | NetUSDChangeCriterion;

export declare interface SendEvmTransactionRule {
    action: SendEvmTransactionRuleAction;
    operation: SendEvmTransactionRuleOperation;
    criteria: SendEvmTransactionCriteria;
}

export declare type SendEvmTransactionRuleAction = (typeof SendEvmTransactionRuleAction)[keyof typeof SendEvmTransactionRuleAction];

export declare const SendEvmTransactionRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SendEvmTransactionRuleOperation = (typeof SendEvmTransactionRuleOperation)[keyof typeof SendEvmTransactionRuleOperation];

export declare const SendEvmTransactionRuleOperation: {
    readonly sendEvmTransaction: "sendEvmTransaction";
};

export declare const sendEvmTransactionWithEndUserAccount: (projectId: string, userId: string, sendEvmTransactionWithEndUserAccountBody: SendEvmTransactionWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SendEvmTransactionWithEndUserAccount200>;

export declare type SendEvmTransactionWithEndUserAccount200 = {
    transactionHash: string;
};

export declare type SendEvmTransactionWithEndUserAccountBody = {
    address: string;
    network: SendEvmTransactionWithEndUserAccountBodyNetwork;
    walletSecretId: string;
    transaction: string;
};

export declare type SendEvmTransactionWithEndUserAccountBodyNetwork = (typeof SendEvmTransactionWithEndUserAccountBodyNetwork)[keyof typeof SendEvmTransactionWithEndUserAccountBodyNetwork];

export declare const SendEvmTransactionWithEndUserAccountBodyNetwork: {
    readonly base: "base";
    readonly "base-sepolia": "base-sepolia";
    readonly ethereum: "ethereum";
    readonly "ethereum-sepolia": "ethereum-sepolia";
    readonly avalanche: "avalanche";
    readonly polygon: "polygon";
    readonly optimism: "optimism";
    readonly arbitrum: "arbitrum";
};

export declare type SendEvmTransactionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof sendEvmTransactionWithEndUserAccount>>>;

export declare const sendSolanaTransactionWithEndUserAccount: (projectId: string, userId: string, sendSolanaTransactionWithEndUserAccountBody: SendSolanaTransactionWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SendSolanaTransactionWithEndUserAccount200>;

export declare type SendSolanaTransactionWithEndUserAccount200 = {
    transactionSignature: string;
};

export declare type SendSolanaTransactionWithEndUserAccountBody = {
    address: string;
    network: SendSolanaTransactionWithEndUserAccountBodyNetwork;
    walletSecretId: string;
    transaction: string;
};

export declare type SendSolanaTransactionWithEndUserAccountBodyNetwork = (typeof SendSolanaTransactionWithEndUserAccountBodyNetwork)[keyof typeof SendSolanaTransactionWithEndUserAccountBodyNetwork];

export declare const SendSolanaTransactionWithEndUserAccountBodyNetwork: {
    readonly solana: "solana";
    readonly "solana-devnet": "solana-devnet";
};

export declare type SendSolanaTransactionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof sendSolanaTransactionWithEndUserAccount>>>;

export declare type SendSolTransactionCriteria = SendSolTransactionCriteriaItem[];

export declare type SendSolTransactionCriteriaItem = SolAddressCriterion | SolValueCriterion | SplAddressCriterion | SplValueCriterion | MintAddressCriterion | SolDataCriterion | ProgramIdCriterion | SolNetworkCriterion;

export declare interface SendSolTransactionRule {
    action: SendSolTransactionRuleAction;
    operation: SendSolTransactionRuleOperation;
    criteria: SendSolTransactionCriteria;
}

export declare type SendSolTransactionRuleAction = (typeof SendSolTransactionRuleAction)[keyof typeof SendSolTransactionRuleAction];

export declare const SendSolTransactionRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SendSolTransactionRuleOperation = (typeof SendSolTransactionRuleOperation)[keyof typeof SendSolTransactionRuleOperation];

export declare const SendSolTransactionRuleOperation: {
    readonly sendSolTransaction: "sendSolTransaction";
};

export declare type SendUserOperationCriteria = SendUserOperationCriteriaItem[];

export declare type SendUserOperationCriteriaItem = EthValueCriterion | EvmAddressCriterion | EvmDataCriterion | NetUSDChangeCriterion;

export declare interface SendUserOperationRule {
    action: SendUserOperationRuleAction;
    operation: SendUserOperationRuleOperation;
    criteria: SendUserOperationCriteria;
}

export declare type SendUserOperationRuleAction = (typeof SendUserOperationRuleAction)[keyof typeof SendUserOperationRuleAction];

export declare const SendUserOperationRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SendUserOperationRuleOperation = (typeof SendUserOperationRuleOperation)[keyof typeof SendUserOperationRuleOperation];

export declare const SendUserOperationRuleOperation: {
    readonly sendUserOperation: "sendUserOperation";
};

export declare const sendUserOperationWithEndUserAccount: (projectId: string, userId: string, address: string, sendUserOperationWithEndUserAccountBody: SendUserOperationWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<EvmUserOperation>;

export declare type SendUserOperationWithEndUserAccountBody = {
    network: EvmUserOperationNetwork;
    calls: EvmCall[];
    useCdpPaymaster: boolean;
    paymasterUrl?: string;
    walletSecretId: string;
};

export declare type SendUserOperationWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof sendUserOperationWithEndUserAccount>>>;

export declare type ServiceUnavailableErrorResponse = Error_2;

export declare const setAuthManager: (manager: AuthManager) => void;

export declare type SignerAddress = string;

export declare interface SignEvmHashRule {
    action: SignEvmHashRuleAction;
    operation: SignEvmHashRuleOperation;
}

export declare type SignEvmHashRuleAction = (typeof SignEvmHashRuleAction)[keyof typeof SignEvmHashRuleAction];

export declare const SignEvmHashRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignEvmHashRuleOperation = (typeof SignEvmHashRuleOperation)[keyof typeof SignEvmHashRuleOperation];

export declare const SignEvmHashRuleOperation: {
    readonly signEvmHash: "signEvmHash";
};

export declare const signEvmHashWithEndUserAccount: (projectId: string, userId: string, signEvmHashWithEndUserAccountBody: SignEvmHashWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignEvmHashWithEndUserAccount200>;

export declare type SignEvmHashWithEndUserAccount200 = {
    signature: string;
};

export declare type SignEvmHashWithEndUserAccountBody = {
    hash: string;
    address: string;
    walletSecretId: string;
};

export declare type SignEvmHashWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signEvmHashWithEndUserAccount>>>;

export declare type SignEvmMessageCriteria = EvmMessageCriterion[];

export declare interface SignEvmMessageRule {
    action: SignEvmMessageRuleAction;
    operation: SignEvmMessageRuleOperation;
    criteria: SignEvmMessageCriteria;
}

export declare type SignEvmMessageRuleAction = (typeof SignEvmMessageRuleAction)[keyof typeof SignEvmMessageRuleAction];

export declare const SignEvmMessageRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignEvmMessageRuleOperation = (typeof SignEvmMessageRuleOperation)[keyof typeof SignEvmMessageRuleOperation];

export declare const SignEvmMessageRuleOperation: {
    readonly signEvmMessage: "signEvmMessage";
};

export declare const signEvmMessageWithEndUserAccount: (projectId: string, userId: string, signEvmMessageWithEndUserAccountBody: SignEvmMessageWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignEvmMessageWithEndUserAccount200>;

export declare type SignEvmMessageWithEndUserAccount200 = {
    signature: string;
};

export declare type SignEvmMessageWithEndUserAccountBody = {
    address: string;
    message: string;
    walletSecretId: string;
};

export declare type SignEvmMessageWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signEvmMessageWithEndUserAccount>>>;

export declare type SignEvmTransactionCriteria = SignEvmTransactionCriteriaItem[];

export declare type SignEvmTransactionCriteriaItem = EthValueCriterion | EvmAddressCriterion | EvmDataCriterion | NetUSDChangeCriterion;

export declare interface SignEvmTransactionRule {
    action: SignEvmTransactionRuleAction;
    operation: SignEvmTransactionRuleOperation;
    criteria: SignEvmTransactionCriteria;
}

export declare type SignEvmTransactionRuleAction = (typeof SignEvmTransactionRuleAction)[keyof typeof SignEvmTransactionRuleAction];

export declare const SignEvmTransactionRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignEvmTransactionRuleOperation = (typeof SignEvmTransactionRuleOperation)[keyof typeof SignEvmTransactionRuleOperation];

export declare const SignEvmTransactionRuleOperation: {
    readonly signEvmTransaction: "signEvmTransaction";
};

export declare const signEvmTransactionWithEndUserAccount: (projectId: string, userId: string, signEvmTransactionWithEndUserAccountBody: SignEvmTransactionWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignEvmTransactionWithEndUserAccount200>;

export declare type SignEvmTransactionWithEndUserAccount200 = {
    signedTransaction: string;
};

export declare type SignEvmTransactionWithEndUserAccountBody = {
    address: string;
    transaction: string;
    walletSecretId: string;
};

export declare type SignEvmTransactionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signEvmTransactionWithEndUserAccount>>>;

export declare type SignEvmTypedDataCriteria = SignEvmTypedDataCriteriaItem[];

export declare type SignEvmTypedDataCriteriaItem = SignEvmTypedDataFieldCriterion | SignEvmTypedDataVerifyingContractCriterion;

export declare interface SignEvmTypedDataFieldCriterion {
    type: SignEvmTypedDataFieldCriterionType;
    types: SignEvmTypedDataFieldCriterionTypes;
    conditions: SignEvmTypedDataFieldCriterionConditionsItem[];
}

export declare type SignEvmTypedDataFieldCriterionConditionsItem = EvmTypedAddressCondition | EvmTypedNumericalCondition | EvmTypedStringCondition;

export declare type SignEvmTypedDataFieldCriterionType = (typeof SignEvmTypedDataFieldCriterionType)[keyof typeof SignEvmTypedDataFieldCriterionType];

export declare const SignEvmTypedDataFieldCriterionType: {
    readonly evmTypedDataField: "evmTypedDataField";
};

export declare type SignEvmTypedDataFieldCriterionTypes = {
    types: SignEvmTypedDataFieldCriterionTypesTypes;
    primaryType: string;
};

export declare type SignEvmTypedDataFieldCriterionTypesTypes = {
    [key: string]: SignEvmTypedDataFieldCriterionTypesTypesItem[];
};

export declare type SignEvmTypedDataFieldCriterionTypesTypesItem = {
    name?: string;
    type?: string;
};

export declare interface SignEvmTypedDataRule {
    action: SignEvmTypedDataRuleAction;
    operation: SignEvmTypedDataRuleOperation;
    criteria: SignEvmTypedDataCriteria;
}

export declare type SignEvmTypedDataRuleAction = (typeof SignEvmTypedDataRuleAction)[keyof typeof SignEvmTypedDataRuleAction];

export declare const SignEvmTypedDataRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignEvmTypedDataRuleOperation = (typeof SignEvmTypedDataRuleOperation)[keyof typeof SignEvmTypedDataRuleOperation];

export declare const SignEvmTypedDataRuleOperation: {
    readonly signEvmTypedData: "signEvmTypedData";
};

export declare interface SignEvmTypedDataVerifyingContractCriterion {
    type: SignEvmTypedDataVerifyingContractCriterionType;
    addresses: string[];
    operator: SignEvmTypedDataVerifyingContractCriterionOperator;
}

export declare type SignEvmTypedDataVerifyingContractCriterionOperator = (typeof SignEvmTypedDataVerifyingContractCriterionOperator)[keyof typeof SignEvmTypedDataVerifyingContractCriterionOperator];

export declare const SignEvmTypedDataVerifyingContractCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type SignEvmTypedDataVerifyingContractCriterionType = (typeof SignEvmTypedDataVerifyingContractCriterionType)[keyof typeof SignEvmTypedDataVerifyingContractCriterionType];

export declare const SignEvmTypedDataVerifyingContractCriterionType: {
    readonly evmTypedDataVerifyingContract: "evmTypedDataVerifyingContract";
};

export declare const signEvmTypedDataWithEndUserAccount: (projectId: string, userId: string, signEvmTypedDataWithEndUserAccountBody: SignEvmTypedDataWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignEvmTypedDataWithEndUserAccount200>;

export declare type SignEvmTypedDataWithEndUserAccount200 = {
    signature: string;
};

export declare type SignEvmTypedDataWithEndUserAccountBody = {
    address: string;
    typedData: EIP712Message;
    walletSecretId: string;
};

export declare type SignEvmTypedDataWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signEvmTypedDataWithEndUserAccount>>>;

export declare const signSolanaHashWithEndUserAccount: (projectId: string, userId: string, signSolanaHashWithEndUserAccountBody: SignSolanaHashWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignSolanaHashWithEndUserAccount200>;

export declare type SignSolanaHashWithEndUserAccount200 = {
    signature: string;
};

export declare type SignSolanaHashWithEndUserAccountBody = {
    hash: string;
    address: string;
    walletSecretId: string;
};

export declare type SignSolanaHashWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signSolanaHashWithEndUserAccount>>>;

export declare const signSolanaMessageWithEndUserAccount: (projectId: string, userId: string, signSolanaMessageWithEndUserAccountBody: SignSolanaMessageWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignSolanaMessageWithEndUserAccount200>;

export declare type SignSolanaMessageWithEndUserAccount200 = {
    signature: string;
};

export declare type SignSolanaMessageWithEndUserAccountBody = {
    address: string;
    message: string;
    walletSecretId: string;
};

export declare type SignSolanaMessageWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signSolanaMessageWithEndUserAccount>>>;

export declare const signSolanaTransactionWithEndUserAccount: (projectId: string, userId: string, signSolanaTransactionWithEndUserAccountBody: SignSolanaTransactionWithEndUserAccountBody, options?: SecondParameter<typeof cdpApiClient>) => Promise<SignSolanaTransactionWithEndUserAccount200>;

export declare type SignSolanaTransactionWithEndUserAccount200 = {
    signedTransaction: string;
};

export declare type SignSolanaTransactionWithEndUserAccountBody = {
    address: string;
    transaction: string;
    walletSecretId: string;
};

export declare type SignSolanaTransactionWithEndUserAccountResult = NonNullable<Awaited<ReturnType<typeof signSolanaTransactionWithEndUserAccount>>>;

export declare type SignSolMessageCriteria = SolMessageCriterion[];

export declare interface SignSolMessageRule {
    action: SignSolMessageRuleAction;
    operation: SignSolMessageRuleOperation;
    criteria: SignSolMessageCriteria;
}

export declare type SignSolMessageRuleAction = (typeof SignSolMessageRuleAction)[keyof typeof SignSolMessageRuleAction];

export declare const SignSolMessageRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignSolMessageRuleOperation = (typeof SignSolMessageRuleOperation)[keyof typeof SignSolMessageRuleOperation];

export declare const SignSolMessageRuleOperation: {
    readonly signSolMessage: "signSolMessage";
};

export declare type SignSolTransactionCriteria = SignSolTransactionCriteriaItem[];

export declare type SignSolTransactionCriteriaItem = SolAddressCriterion | SolValueCriterion | SplAddressCriterion | SplValueCriterion | MintAddressCriterion | SolDataCriterion | ProgramIdCriterion;

export declare interface SignSolTransactionRule {
    action: SignSolTransactionRuleAction;
    operation: SignSolTransactionRuleOperation;
    criteria: SignSolTransactionCriteria;
}

export declare type SignSolTransactionRuleAction = (typeof SignSolTransactionRuleAction)[keyof typeof SignSolTransactionRuleAction];

export declare const SignSolTransactionRuleAction: {
    readonly reject: "reject";
    readonly accept: "accept";
};

export declare type SignSolTransactionRuleOperation = (typeof SignSolTransactionRuleOperation)[keyof typeof SignSolTransactionRuleOperation];

export declare const SignSolTransactionRuleOperation: {
    readonly signSolTransaction: "signSolTransaction";
};

export declare type SlippageBps = number;

export declare interface SmsAuthentication {
    type: SmsAuthenticationType;
    phoneNumber: string;
}

export declare type SmsAuthenticationType = (typeof SmsAuthenticationType)[keyof typeof SmsAuthenticationType];

export declare const SmsAuthenticationType: {
    readonly sms: "sms";
};

export declare interface SolAddressCriterion {
    type: SolAddressCriterionType;
    addresses: string[];
    operator: SolAddressCriterionOperator;
}

export declare type SolAddressCriterionOperator = (typeof SolAddressCriterionOperator)[keyof typeof SolAddressCriterionOperator];

export declare const SolAddressCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type SolAddressCriterionType = (typeof SolAddressCriterionType)[keyof typeof SolAddressCriterionType];

export declare const SolAddressCriterionType: {
    readonly solAddress: "solAddress";
};

export declare interface SolanaAccount {
    address: string;
    name?: string;
    policies?: string[];
    createdAt?: string;
    updatedAt?: string;
}

export declare interface SolanaToken {
    symbol?: string;
    name?: string;
    mintAddress: string;
}

export declare interface SolanaTokenAmount {
    amount: string;
    decimals: number;
}

export declare interface SolanaTokenBalance {
    amount: SolanaTokenAmount;
    token: SolanaToken;
}

export declare interface SolDataCondition {
    instruction: string;
    params?: SolDataConditionParamsItem[];
}

export declare type SolDataConditionParamsItem = SolDataParameterCondition | SolDataParameterConditionList;

export declare interface SolDataCriterion {
    type: SolDataCriterionType;
    idls: SolDataCriterionIdlsItem[];
    conditions: SolDataCondition[];
}

export declare type SolDataCriterionIdlsItem = KnownIdlType | Idl;

export declare type SolDataCriterionType = (typeof SolDataCriterionType)[keyof typeof SolDataCriterionType];

export declare const SolDataCriterionType: {
    readonly solData: "solData";
};

export declare interface SolDataParameterCondition {
    name: string;
    operator: SolDataParameterConditionOperator;
    value: string;
}

export declare interface SolDataParameterConditionList {
    name: string;
    operator: SolDataParameterConditionListOperator;
    values: string[];
}

export declare type SolDataParameterConditionListOperator = (typeof SolDataParameterConditionListOperator)[keyof typeof SolDataParameterConditionListOperator];

export declare const SolDataParameterConditionListOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type SolDataParameterConditionOperator = (typeof SolDataParameterConditionOperator)[keyof typeof SolDataParameterConditionOperator];

export declare const SolDataParameterConditionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare interface SolMessageCriterion {
    type: SolMessageCriterionType;
    match: string;
}

export declare type SolMessageCriterionType = (typeof SolMessageCriterionType)[keyof typeof SolMessageCriterionType];

export declare const SolMessageCriterionType: {
    readonly solMessage: "solMessage";
};

export declare interface SolNetworkCriterion {
    type: SolNetworkCriterionType;
    networks: SolNetworkCriterionNetworksItem[];
    operator: SolNetworkCriterionOperator;
}

export declare type SolNetworkCriterionNetworksItem = (typeof SolNetworkCriterionNetworksItem)[keyof typeof SolNetworkCriterionNetworksItem];

export declare const SolNetworkCriterionNetworksItem: {
    readonly "solana-devnet": "solana-devnet";
    readonly solana: "solana";
};

export declare type SolNetworkCriterionOperator = (typeof SolNetworkCriterionOperator)[keyof typeof SolNetworkCriterionOperator];

export declare const SolNetworkCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type SolNetworkCriterionType = (typeof SolNetworkCriterionType)[keyof typeof SolNetworkCriterionType];

export declare const SolNetworkCriterionType: {
    readonly solNetwork: "solNetwork";
};

export declare interface SolValueCriterion {
    type: SolValueCriterionType;
    solValue: string;
    operator: SolValueCriterionOperator;
}

export declare type SolValueCriterionOperator = (typeof SolValueCriterionOperator)[keyof typeof SolValueCriterionOperator];

export declare const SolValueCriterionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare type SolValueCriterionType = (typeof SolValueCriterionType)[keyof typeof SolValueCriterionType];

export declare const SolValueCriterionType: {
    readonly solValue: "solValue";
};

export declare interface SpendPermission {
    account: string;
    spender: string;
    token: string;
    allowance: string;
    period: string;
    start: string;
    end: string;
    salt: string;
    extraData: string;
}

export declare type SpendPermissionNetwork = (typeof SpendPermissionNetwork)[keyof typeof SpendPermissionNetwork];

export declare const SpendPermissionNetwork: {
    readonly base: "base";
    readonly "base-sepolia": "base-sepolia";
    readonly ethereum: "ethereum";
    readonly "ethereum-sepolia": "ethereum-sepolia";
    readonly optimism: "optimism";
    readonly arbitrum: "arbitrum";
    readonly avalanche: "avalanche";
    readonly polygon: "polygon";
};

export declare interface SpendPermissionResponseObject {
    permission: SpendPermission;
    permissionHash: string;
    revoked: boolean;
    revokedAt?: string;
    createdAt: string;
    network: SpendPermissionNetwork;
}

export declare interface SplAddressCriterion {
    type: SplAddressCriterionType;
    addresses: string[];
    operator: SplAddressCriterionOperator;
}

export declare type SplAddressCriterionOperator = (typeof SplAddressCriterionOperator)[keyof typeof SplAddressCriterionOperator];

export declare const SplAddressCriterionOperator: {
    readonly in: "in";
    readonly not_in: "not in";
};

export declare type SplAddressCriterionType = (typeof SplAddressCriterionType)[keyof typeof SplAddressCriterionType];

export declare const SplAddressCriterionType: {
    readonly splAddress: "splAddress";
};

export declare interface SplValueCriterion {
    type: SplValueCriterionType;
    splValue: string;
    operator: SplValueCriterionOperator;
}

export declare type SplValueCriterionOperator = (typeof SplValueCriterionOperator)[keyof typeof SplValueCriterionOperator];

export declare const SplValueCriterionOperator: {
    readonly ">": ">";
    readonly ">=": ">=";
    readonly "<": "<";
    readonly "<=": "<=";
    readonly "==": "==";
};

export declare type SplValueCriterionType = (typeof SplValueCriterionType)[keyof typeof SplValueCriterionType];

export declare const SplValueCriterionType: {
    readonly splValue: "splValue";
};

export declare interface SwapUnavailableResponse {
    liquidityAvailable: boolean;
}

export declare type Taker = string;

export declare interface TeamMember {
    memberId: TeamMemberId;
    userId: string;
    entityId: EntityId;
    sandbox?: boolean;
    email: string;
    role: Role;
    kycRequired: boolean;
}

export declare type TeamMemberId = string;

export declare type TimedOutErrorResponse = Error_2;

export declare interface Token {
    network: ListEvmTokenBalancesNetwork;
    symbol?: string;
    name?: string;
    contractAddress: string;
}

export declare interface TokenAmount {
    amount: string;
    decimals: number;
}

export declare interface TokenBalance {
    amount: TokenAmount;
    token: Token;
}

export declare interface TokenFee {
    amount: string;
    token: string;
}

export declare type ToToken = string;

export declare interface Transfer {
    transferId: string;
    status: TransferStatus;
    source: TransferSource;
    target: TransferTarget;
    amount: string;
    asset: string;
    sourceAmount?: string;
    sourceAsset?: string;
    targetAmount?: string;
    targetAsset?: string;
    exchangeRate?: TransferExchangeRate;
    fees?: TransferFees;
    onchainTransactions?: OnchainTransaction[];
    completedAt?: string;
    failureReason?: string;
    reversalReason?: TransferReversalReason;
    cancellationReason?: TransferCancellationReason;
    lastError?: TransferLastError;
    expiresAt?: string;
    executedAt?: string;
    createdAt: string;
    updatedAt: string;
}

export declare type TransferCancellationReason = (typeof TransferCancellationReason)[keyof typeof TransferCancellationReason];

export declare const TransferCancellationReason: {
    readonly user_canceled: "user_canceled";
    readonly system_canceled: "system_canceled";
    readonly expired: "expired";
    readonly compliance_canceled: "compliance_canceled";
    readonly risk_canceled: "risk_canceled";
    readonly duplicate_canceled: "duplicate_canceled";
    readonly insufficient_funds_canceled: "insufficient_funds_canceled";
};

export declare type TransferExchangeRate = {
    sourceAsset: string;
    targetAsset: string;
    rate: string;
};

export declare interface TransferFee {
    name: TransferFeeName;
    amount: string;
    asset: string;
}

export declare type TransferFeeName = (typeof TransferFeeName)[keyof typeof TransferFeeName];

export declare const TransferFeeName: {
    readonly network_fee: "network_fee";
    readonly processing_fee: "processing_fee";
    readonly wire_fee: "wire_fee";
    readonly exchange_fee: "exchange_fee";
    readonly spread_fee: "spread_fee";
};

export declare type TransferFees = TransferFee[];

export declare type TransferLastError = {
    code?: string;
    message?: string;
    param?: string;
    details?: TransferLastErrorDetails;
};

export declare type TransferLastErrorDetails = {
    availableBalance?: string;
    requiredAmount?: string;
    retryAfter?: number;
};

export declare interface TransferRequest {
    source: TransferSource;
    target: TransferTarget;
    amount: string;
    asset: string;
    amountType?: TransferRequestAmountType;
    execute: boolean;
}

export declare type TransferRequestAmountType = (typeof TransferRequestAmountType)[keyof typeof TransferRequestAmountType];

export declare const TransferRequestAmountType: {
    readonly target: "target";
    readonly source: "source";
};

export declare type TransferReversalReason = (typeof TransferReversalReason)[keyof typeof TransferReversalReason];

export declare const TransferReversalReason: {
    readonly user_requested: "user_requested";
    readonly compliance_reversal: "compliance_reversal";
    readonly fraud_reversal: "fraud_reversal";
    readonly network_reversal: "network_reversal";
    readonly system_reversal: "system_reversal";
};

export declare interface TransfersAccount {
    accountId: string;
    asset: string;
}

export declare type TransferSource = TransfersAccount | PaymentMethod;

export declare type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus];

export declare const TransferStatus: {
    readonly draft: "draft";
    readonly awaiting_funds: "awaiting_funds";
    readonly processing: "processing";
    readonly completed: "completed";
    readonly failed: "failed";
    readonly canceled: "canceled";
    readonly expired: "expired";
    readonly reversed: "reversed";
};

export declare type TransferTarget = TransfersAccount | PaymentMethod | OnchainAddress | EmailAddress;

export declare type UnauthorizedErrorResponse = Error_2;

export declare class UnknownApiError extends APIError {
    constructor(errorType: APIErrorType, errorMessage: string, cause?: Error);
}

export declare class UnknownError extends Error {
    constructor(message: string, cause?: Error);
}

export declare interface UserOperationReceipt {
    revert?: UserOperationReceiptRevert;
    transactionHash?: string;
    blockHash?: string;
    blockNumber?: number;
    gasUsed?: string;
}

export declare interface UserOperationReceiptRevert {
    data: string;
    message: string;
}

export declare const verifyEmailAuthentication: (projectId: string, verifyEmailAuthenticationRequest: VerifyEmailAuthenticationRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<VerifyEmailAuthentication200>;

export declare type VerifyEmailAuthentication200 = {
    endUser: EndUser;
    isNewEndUser: boolean;
    message: string;
    accessToken: string;
    validUntil: string;
    refreshToken?: string;
};

export declare interface VerifyEmailAuthenticationRequest {
    flowId: string;
    otp: string;
}

export declare type VerifyEmailAuthenticationResult = NonNullable<Awaited<ReturnType<typeof verifyEmailAuthentication>>>;

export declare const verifyOAuthCode: (projectId: string, providerType: OAuth2ProviderType, verifyOAuthCodeRequest: VerifyOAuthCodeRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<VerifyOAuthCode200>;

export declare type VerifyOAuthCode200 = {
    endUser: EndUser;
    isNewEndUser: boolean;
    message: string;
    accessToken: string;
    validUntil: string;
    refreshToken?: string;
};

export declare interface VerifyOAuthCodeRequest {
    flowId: string;
    code: string;
}

export declare type VerifyOAuthCodeResult = NonNullable<Awaited<ReturnType<typeof verifyOAuthCode>>>;

export declare const verifySmsAuthentication: (projectId: string, verifySmsAuthenticationRequest: VerifySmsAuthenticationRequest, options?: SecondParameter<typeof cdpApiClient>) => Promise<VerifySmsAuthentication200>;

export declare type VerifySmsAuthentication200 = {
    endUser: EndUser;
    isNewEndUser: boolean;
    message: string;
    accessToken: string;
    validUntil: string;
    refreshToken?: string;
};

export declare interface VerifySmsAuthenticationRequest {
    flowId: string;
    otp: string;
}

export declare type VerifySmsAuthenticationResult = NonNullable<Awaited<ReturnType<typeof verifySmsAuthentication>>>;

export declare interface WalletSecretMetadata {
    updatedAt: string;
}

export declare type WebhookSubscriptionListResponse = WebhookSubscriptionListResponseAllOf & ListResponse;

export declare type WebhookSubscriptionListResponseAllOf = {
    subscriptions: WebhookSubscriptionResponse[];
};

export declare type WebhookSubscriptionRequest = (unknown & {
    description?: string;
    eventTypes?: string[];
    isEnabled?: boolean;
    target?: WebhookTarget;
    metadata?: WebhookSubscriptionRequestMetadata;
    labelKey?: string;
    labelValue?: string;
    labels?: WebhookSubscriptionRequestLabels;
}) | (unknown & {
    description?: string;
    eventTypes?: string[];
    isEnabled?: boolean;
    target?: WebhookTarget;
    metadata?: WebhookSubscriptionRequestMetadata;
    labelKey?: string;
    labelValue?: string;
    labels?: WebhookSubscriptionRequestLabels;
});

export declare type WebhookSubscriptionRequestLabels = {
    [key: string]: string;
};

export declare type WebhookSubscriptionRequestMetadata = {
    [key: string]: unknown;
};

export declare interface WebhookSubscriptionResponse {
    createdAt: string;
    description?: string;
    eventTypes: string[];
    isEnabled: boolean;
    metadata?: WebhookSubscriptionResponseMetadata;
    subscriptionId: string;
    target: WebhookTarget;
    labelKey?: string;
    labelValue?: string;
    labels?: WebhookSubscriptionResponseLabels;
}

export declare type WebhookSubscriptionResponseLabels = {
    [key: string]: string;
};

export declare type WebhookSubscriptionResponseMetadata = {
    secret?: string;
};

export declare type WebhookSubscriptionUpdateRequest = (unknown & {
    description?: string;
    eventTypes?: string[];
    isEnabled?: boolean;
    target?: WebhookTarget;
    metadata?: WebhookSubscriptionUpdateRequestMetadata;
    labelKey?: string;
    labelValue?: string;
    labels?: WebhookSubscriptionUpdateRequestLabels;
}) | (unknown & {
    description?: string;
    eventTypes?: string[];
    isEnabled?: boolean;
    target?: WebhookTarget;
    metadata?: WebhookSubscriptionUpdateRequestMetadata;
    labelKey?: string;
    labelValue?: string;
    labels?: WebhookSubscriptionUpdateRequestLabels;
});

export declare type WebhookSubscriptionUpdateRequestLabels = {
    [key: string]: string;
};

export declare type WebhookSubscriptionUpdateRequestMetadata = {
    [key: string]: unknown;
};

export declare interface WebhookTarget {
    url: string;
    headers?: WebhookTargetHeaders;
}

export declare type WebhookTargetHeaders = {
    [key: string]: string;
};

export declare interface X402DiscoveryResource {
    resource: string;
    type: X402DiscoveryResourceType;
    x402Version: X402Version;
    accepts?: X402PaymentRequirements[];
    lastUpdated: string;
    metadata?: X402DiscoveryResourceMetadata;
}

export declare type X402DiscoveryResourceMetadata = {
    [key: string]: unknown;
};

export declare interface X402DiscoveryResourcesResponse {
    x402Version: X402Version;
    items: X402DiscoveryResource[];
    pagination: X402DiscoveryResourcesResponsePagination;
}

export declare type X402DiscoveryResourcesResponsePagination = {
    limit?: number;
    offset?: number;
    total?: number;
};

export declare type X402DiscoveryResourceType = (typeof X402DiscoveryResourceType)[keyof typeof X402DiscoveryResourceType];

export declare const X402DiscoveryResourceType: {
    readonly http: "http";
};

export declare interface X402ExactEvmPayload {
    signature: string;
    authorization: X402ExactEvmPayloadAuthorization;
}

export declare type X402ExactEvmPayloadAuthorization = {
    from: string;
    to: string;
    value: string;
    validAfter: string;
    validBefore: string;
    nonce: string;
};

export declare interface X402ExactSolanaPayload {
    transaction: string;
}

export declare interface X402PaymentPayload {
    x402Version: X402Version;
    scheme: X402PaymentPayloadScheme;
    network: X402PaymentPayloadNetwork;
    payload: X402PaymentPayloadPayload;
}

export declare type X402PaymentPayloadNetwork = (typeof X402PaymentPayloadNetwork)[keyof typeof X402PaymentPayloadNetwork];

export declare const X402PaymentPayloadNetwork: {
    readonly "base-sepolia": "base-sepolia";
    readonly base: "base";
    readonly "solana-devnet": "solana-devnet";
    readonly solana: "solana";
};

export declare type X402PaymentPayloadPayload = X402ExactEvmPayload | X402ExactSolanaPayload;

export declare type X402PaymentPayloadScheme = (typeof X402PaymentPayloadScheme)[keyof typeof X402PaymentPayloadScheme];

export declare const X402PaymentPayloadScheme: {
    readonly exact: "exact";
};

export declare interface X402PaymentRequirements {
    scheme: X402PaymentRequirementsScheme;
    network: X402PaymentRequirementsNetwork;
    maxAmountRequired: string;
    resource: string;
    description: string;
    mimeType: string;
    outputSchema?: X402PaymentRequirementsOutputSchema;
    payTo: string;
    maxTimeoutSeconds: number;
    asset: string;
    extra?: X402PaymentRequirementsExtra;
}

export declare type X402PaymentRequirementsExtra = {
    [key: string]: unknown;
};

export declare type X402PaymentRequirementsNetwork = (typeof X402PaymentRequirementsNetwork)[keyof typeof X402PaymentRequirementsNetwork];

export declare const X402PaymentRequirementsNetwork: {
    readonly "base-sepolia": "base-sepolia";
    readonly base: "base";
    readonly "solana-devnet": "solana-devnet";
    readonly solana: "solana";
};

export declare type X402PaymentRequirementsOutputSchema = {
    [key: string]: unknown;
};

export declare type X402PaymentRequirementsScheme = (typeof X402PaymentRequirementsScheme)[keyof typeof X402PaymentRequirementsScheme];

export declare const X402PaymentRequirementsScheme: {
    readonly exact: "exact";
};

export declare type X402SettleErrorReason = (typeof X402SettleErrorReason)[keyof typeof X402SettleErrorReason];

export declare const X402SettleErrorReason: {
    readonly insufficient_funds: "insufficient_funds";
    readonly invalid_scheme: "invalid_scheme";
    readonly invalid_network: "invalid_network";
    readonly invalid_x402_version: "invalid_x402_version";
    readonly invalid_payment_requirements: "invalid_payment_requirements";
    readonly invalid_payload: "invalid_payload";
    readonly invalid_exact_evm_payload_authorization_value: "invalid_exact_evm_payload_authorization_value";
    readonly invalid_exact_evm_payload_authorization_valid_after: "invalid_exact_evm_payload_authorization_valid_after";
    readonly invalid_exact_evm_payload_authorization_valid_before: "invalid_exact_evm_payload_authorization_valid_before";
    readonly invalid_exact_evm_payload_authorization_typed_data_message: "invalid_exact_evm_payload_authorization_typed_data_message";
    readonly invalid_exact_evm_payload_authorization_from_address_kyt: "invalid_exact_evm_payload_authorization_from_address_kyt";
    readonly invalid_exact_evm_payload_authorization_to_address_kyt: "invalid_exact_evm_payload_authorization_to_address_kyt";
    readonly invalid_exact_evm_payload_signature_address: "invalid_exact_evm_payload_signature_address";
    readonly settle_exact_svm_block_height_exceeded: "settle_exact_svm_block_height_exceeded";
    readonly settle_exact_svm_transaction_confirmation_timed_out: "settle_exact_svm_transaction_confirmation_timed_out";
};

export declare type X402SettleResponseResponse = {
    success: boolean;
    errorReason?: X402SettleErrorReason;
    payer: string;
    transaction: string;
    network: string;
};

export declare interface X402SupportedPaymentKind {
    x402Version: X402Version;
    scheme: X402SupportedPaymentKindScheme;
    network: X402SupportedPaymentKindNetwork;
    extra?: X402SupportedPaymentKindExtra;
}

export declare type X402SupportedPaymentKindExtra = {
    [key: string]: unknown;
};

export declare type X402SupportedPaymentKindNetwork = (typeof X402SupportedPaymentKindNetwork)[keyof typeof X402SupportedPaymentKindNetwork];

export declare const X402SupportedPaymentKindNetwork: {
    readonly "base-sepolia": "base-sepolia";
    readonly base: "base";
    readonly "solana-devnet": "solana-devnet";
    readonly solana: "solana";
};

export declare type X402SupportedPaymentKindScheme = (typeof X402SupportedPaymentKindScheme)[keyof typeof X402SupportedPaymentKindScheme];

export declare const X402SupportedPaymentKindScheme: {
    readonly exact: "exact";
};

export declare type X402SupportedPaymentKindsResponseResponse = {
    kinds: X402SupportedPaymentKind[];
};

export declare type X402VerifyInvalidReason = (typeof X402VerifyInvalidReason)[keyof typeof X402VerifyInvalidReason];

export declare const X402VerifyInvalidReason: {
    readonly insufficient_funds: "insufficient_funds";
    readonly invalid_scheme: "invalid_scheme";
    readonly invalid_network: "invalid_network";
    readonly invalid_x402_version: "invalid_x402_version";
    readonly invalid_payment_requirements: "invalid_payment_requirements";
    readonly invalid_payload: "invalid_payload";
    readonly invalid_exact_evm_payload_authorization_value: "invalid_exact_evm_payload_authorization_value";
    readonly invalid_exact_evm_payload_authorization_value_too_low: "invalid_exact_evm_payload_authorization_value_too_low";
    readonly invalid_exact_evm_payload_authorization_valid_after: "invalid_exact_evm_payload_authorization_valid_after";
    readonly invalid_exact_evm_payload_authorization_valid_before: "invalid_exact_evm_payload_authorization_valid_before";
    readonly invalid_exact_evm_payload_authorization_typed_data_message: "invalid_exact_evm_payload_authorization_typed_data_message";
    readonly invalid_exact_evm_payload_authorization_from_address_kyt: "invalid_exact_evm_payload_authorization_from_address_kyt";
    readonly invalid_exact_evm_payload_authorization_to_address_kyt: "invalid_exact_evm_payload_authorization_to_address_kyt";
    readonly invalid_exact_evm_payload_signature: "invalid_exact_evm_payload_signature";
    readonly invalid_exact_evm_payload_signature_address: "invalid_exact_evm_payload_signature_address";
    readonly invalid_exact_svm_payload_transaction: "invalid_exact_svm_payload_transaction";
    readonly invalid_exact_svm_payload_transaction_amount_mismatch: "invalid_exact_svm_payload_transaction_amount_mismatch";
    readonly invalid_exact_svm_payload_transaction_create_ata_instruction: "invalid_exact_svm_payload_transaction_create_ata_instruction";
    readonly invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee: "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee";
    readonly invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset: "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset";
    readonly invalid_exact_svm_payload_transaction_instructions: "invalid_exact_svm_payload_transaction_instructions";
    readonly invalid_exact_svm_payload_transaction_instructions_length: "invalid_exact_svm_payload_transaction_instructions_length";
    readonly invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction: "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction";
    readonly invalid_exact_svm_payload_transaction_instructions_compute_price_instruction: "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction";
    readonly invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high: "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high";
    readonly invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked: "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked";
    readonly invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked: "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked";
    readonly invalid_exact_svm_payload_transaction_not_a_transfer_instruction: "invalid_exact_svm_payload_transaction_not_a_transfer_instruction";
    readonly invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata: "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata";
    readonly invalid_exact_svm_payload_transaction_receiver_ata_not_found: "invalid_exact_svm_payload_transaction_receiver_ata_not_found";
    readonly invalid_exact_svm_payload_transaction_sender_ata_not_found: "invalid_exact_svm_payload_transaction_sender_ata_not_found";
    readonly invalid_exact_svm_payload_transaction_simulation_failed: "invalid_exact_svm_payload_transaction_simulation_failed";
    readonly invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata: "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata";
    readonly invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts: "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts";
    readonly invalid_exact_svm_payload_transaction_fee_payer_transferring_funds: "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds";
};

export declare type X402VerifyResponseResponse = {
    isValid: boolean;
    invalidReason?: X402VerifyInvalidReason;
    payer: string;
};

export declare type X402Version = (typeof X402Version)[keyof typeof X402Version];

export declare const X402Version: {
    readonly NUMBER_1: 1;
};

export declare type XDeveloperAuthParameter = string;

export declare type XWalletAuthParameter = string;

export { }
