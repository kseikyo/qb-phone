import c from "axios";
import { ERROR_DOCS_PAGE_URL as d } from "./index9.js";
import { UnknownApiError as m, HttpErrorType as u, isOpenAPIError as v, APIError as i, UnknownError as y } from "./index8.js";
const h = () => typeof window < "u" && typeof document < "u";
let a = c.create({
  baseURL: "https://api.cdp.coinbase.com/platform"
}), o = null;
const $ = (r) => {
  a = c.create({
    baseURL: r.basePath || "https://api.cdp.coinbase.com/platform",
    // Only enable cookies in browser environments where they're supported
    withCredentials: h()
  }), a.interceptors.request.use(async (e) => {
    const t = b(e), s = l(e);
    if (!o || p(s.pathname) || w(s.pathname) && !await o.isSignedIn() || !q(s.pathname))
      return e;
    const n = await o.getXWalletAuth({
      requestMethod: t,
      requestHost: s.host,
      requestPath: s.pathname,
      requestData: e.data
    });
    return n && (e.headers["X-Wallet-Auth"] = n), e;
  }), a.interceptors.request.use(async (e) => {
    const t = l(e);
    if (!o || p(t.pathname) || w(t.pathname) && !await o.isSignedIn())
      return e;
    const s = await o.getToken();
    return s && s !== "" && (e.headers.Authorization = `Bearer ${s}`), e;
  }), h() || a.interceptors.request.use(async (e) => {
    let t = e.headers["User-Agent"];
    return t = t ? `${t} CDP/reactnative` : "CDP/reactnative", e.headers["User-Agent"] = t, e;
  }), r.refreshTokenStorage && R(r.refreshTokenStorage), r.debugging && (a.interceptors.request.use((e) => (console.log("Request:", e), e)), a.interceptors.response.use((e) => (console.log("Response:", e), e)));
}, x = (r) => {
  o = r;
}, A = (r, e) => ({
  ...r,
  headers: {
    ...r.headers || {},
    "X-Idempotency-Key": e
  }
}), I = async (r, e) => {
  T(r), e && e !== "" && (r = A(r, e));
  try {
    return (await a(r)).data;
  } catch (t) {
    if (c.isAxiosError(t) && !t.response)
      throw new m(
        u.unknown,
        t.cause instanceof Error ? t.cause.message : t.message,
        t.cause
      );
    if (c.isAxiosError(t) && t.response) {
      if (v(t.response.data))
        throw new i(
          t.response.status,
          t.response.data.errorType,
          t.response.data.errorMessage,
          t.response.data.correlationId,
          t.response.data.errorLink,
          t.cause
        );
      {
        const s = t.response.status;
        switch (s) {
          case 401:
            throw new i(
              s,
              u.unauthorized,
              "Unauthorized.",
              void 0,
              `${d}#unauthorized`,
              t.cause
            );
          case 404:
            throw new i(
              s,
              u.not_found,
              "API not found.",
              void 0,
              `${d}#not_found`,
              t.cause
            );
          case 502:
            throw new i(
              s,
              u.bad_gateway,
              "Bad gateway.",
              void 0,
              `${d}`,
              t.cause
            );
          case 503:
            throw new i(
              s,
              u.service_unavailable,
              "Service unavailable. Please try again later.",
              void 0,
              `${d}`,
              t.cause
            );
          default: {
            let n = "";
            if (t.response.data)
              try {
                n = JSON.stringify(t.response.data);
              } catch {
                n = String(t.response.data);
              }
            const f = n ? `An unexpected error occurred: ${n}` : "An unexpected error occurred.";
            throw new i(
              s,
              u.unexpected_error,
              f,
              void 0,
              `${d}`,
              t.cause
            );
          }
        }
      }
    }
    throw new y(
      "Something went wrong. Please reach out at https://discord.com/channels/1220414409550336183/1271495764580896789 for help.",
      t instanceof Error ? t : void 0
    );
  }
}, R = (r) => {
  a.interceptors.response.use(
    async (e) => {
      try {
        if (U(e)) {
          const t = e.data?.refreshToken;
          t && await r.setRefreshToken(t);
        }
      } catch (t) {
        console.warn("Failed to store refresh token:", t);
      }
      return e;
    },
    (e) => Promise.reject(e)
  ), a.interceptors.request.use(async (e) => {
    try {
      if (k(e.url)) {
        const t = await r.getRefreshToken();
        t && (e.data = {
          ...e.data,
          refreshToken: t
        });
      }
      P(e.url) && await r.removeRefreshToken();
    } catch (t) {
      console.warn("Failed to retrieve refresh token:", t);
    }
    return e;
  });
}, P = (r) => r ? /^\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/logout$/.test(r) : !1, k = (r) => r ? /^\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/(refresh|logout)$/.test(r) : !1, U = (r) => {
  const e = r.config.url;
  return e ? /^\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/(verify\/(email|sms|oauth\/.*)|refresh)$/.test(
    e
  ) : !1;
}, T = (r) => {
  if (!a.getUri() || a.getUri() === "")
    throw new Error("CDP client URI not configured. Call configure() first.");
  if (!r.url || r.url === "")
    throw new Error("AxiosRequestConfig URL is empty. This should never happen.");
  if (!r.method || r.method === "")
    throw new Error("AxiosRequestConfig method is empty. This should never happen.");
}, b = (r) => r.method?.toString().toUpperCase() || "GET", l = (r) => {
  if (!r.url)
    throw new Error("URL is required for authentication");
  const e = a.getUri() + r.url;
  return new URL(e);
}, p = (r) => /^\/platform\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/(refresh|logout)$/.test(r), q = (r) => !/^\/platform\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/custom\/authenticate$/.test(r), w = (r) => {
  const e = /^\/platform\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/(init)$/, t = /^\/platform\/v2\/embedded-wallet-api\/projects\/[^/]+\/auth\/verify\//;
  return e.test(r) || t.test(r);
};
export {
  I as cdpApiClient,
  $ as configureCdpApiClient,
  x as setAuthManager
};
